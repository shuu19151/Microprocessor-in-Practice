CCS PCM C Compiler, Version 5.109, 43599               29-Nov-22 22:34

               Filename:   C:\Tri\HK 1 nam 4\TT micro\Project\Final\Code\final.lst

               ROM used:   2550 words (31%)
                           Largest free fragment is 2048
               RAM used:   25 (7%) at main() level
                           169 (46%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   1A4
0003:  NOP
.................... #include <final.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA D4,32
000D:  DATA 6D,38
000E:  DATA 3A,10
000F:  DATA 00,00
0010:  DATA 2E,00
0011:  DATA 0C,00
0012:  DATA CD,30
0013:  DATA 78,1D
0014:  DATA A0,12
0015:  DATA 64,00
0016:  DATA CD,34
0017:  DATA 6E,1D
0018:  DATA A0,12
0019:  DATA 64,00
001A:  DATA 41,26
001B:  DATA 00,01
001C:  DATA 20,10
001D:  DATA 00,00
001E:  DATA 0C,00
*
01B2:  MOVF   0B,W
01B3:  BSF    03.5
01B4:  MOVWF  5B
01B5:  BCF    03.5
01B6:  BCF    0B.7
01B7:  BSF    03.5
01B8:  BSF    03.6
01B9:  BSF    0C.7
01BA:  BSF    0C.0
01BB:  NOP
01BC:  NOP
01BD:  BCF    03.6
01BE:  BTFSS  5B.7
01BF:  GOTO   1C3
01C0:  BCF    03.5
01C1:  BSF    0B.7
01C2:  BSF    03.5
01C3:  BCF    03.5
01C4:  BSF    03.6
01C5:  MOVF   0C,W
01C6:  ANDLW  7F
01C7:  BTFSC  03.2
01C8:  GOTO   224
01C9:  BSF    03.5
01CA:  BCF    03.6
01CB:  MOVWF  5B
01CC:  BCF    03.5
01CD:  BSF    03.6
01CE:  MOVF   0D,W
01CF:  BSF    03.5
01D0:  BCF    03.6
01D1:  MOVWF  5C
01D2:  BCF    03.5
01D3:  BSF    03.6
01D4:  MOVF   0F,W
01D5:  BSF    03.5
01D6:  BCF    03.6
01D7:  MOVWF  5D
01D8:  MOVF   5B,W
01D9:  MOVWF  5E
01DA:  BCF    03.5
01DB:  CALL   182
01DC:  BSF    03.5
01DD:  MOVF   5C,W
01DE:  BCF    03.5
01DF:  BSF    03.6
01E0:  MOVWF  0D
01E1:  BSF    03.5
01E2:  BCF    03.6
01E3:  MOVF   5D,W
01E4:  BCF    03.5
01E5:  BSF    03.6
01E6:  MOVWF  0F
01E7:  BCF    03.6
01E8:  MOVF   0B,W
01E9:  BSF    03.5
01EA:  MOVWF  5E
01EB:  BCF    03.5
01EC:  BCF    0B.7
01ED:  BSF    03.5
01EE:  BSF    03.6
01EF:  BSF    0C.7
01F0:  BSF    0C.0
01F1:  NOP
01F2:  NOP
01F3:  BCF    03.6
01F4:  BTFSS  5E.7
01F5:  GOTO   1F9
01F6:  BCF    03.5
01F7:  BSF    0B.7
01F8:  BSF    03.5
01F9:  BCF    03.5
01FA:  BSF    03.6
01FB:  RLF    0C,W
01FC:  RLF    0E,W
01FD:  ANDLW  7F
01FE:  BTFSC  03.2
01FF:  GOTO   224
0200:  BSF    03.5
0201:  BCF    03.6
0202:  MOVWF  5B
0203:  BCF    03.5
0204:  BSF    03.6
0205:  MOVF   0D,W
0206:  BSF    03.5
0207:  BCF    03.6
0208:  MOVWF  5C
0209:  BCF    03.5
020A:  BSF    03.6
020B:  MOVF   0F,W
020C:  BSF    03.5
020D:  BCF    03.6
020E:  MOVWF  5D
020F:  MOVF   5B,W
0210:  MOVWF  5E
0211:  BCF    03.5
0212:  CALL   182
0213:  BSF    03.5
0214:  MOVF   5C,W
0215:  BCF    03.5
0216:  BSF    03.6
0217:  MOVWF  0D
0218:  BSF    03.5
0219:  BCF    03.6
021A:  MOVF   5D,W
021B:  BCF    03.5
021C:  BSF    03.6
021D:  MOVWF  0F
021E:  INCF   0D,F
021F:  BTFSC  03.2
0220:  INCF   0F,F
0221:  BCF    03.6
0222:  GOTO   1B2
0223:  BSF    03.6
0224:  BCF    03.6
0225:  RETURN
*
0353:  MOVLW  8E
0354:  MOVWF  77
0355:  MOVF   3E,W
0356:  MOVWF  78
0357:  MOVF   3D,W
0358:  MOVWF  79
0359:  CLRF   7A
035A:  MOVF   78,F
035B:  BTFSS  03.2
035C:  GOTO   367
035D:  MOVF   79,W
035E:  MOVWF  78
035F:  CLRF   79
0360:  MOVLW  08
0361:  SUBWF  77,F
0362:  MOVF   78,F
0363:  BTFSS  03.2
0364:  GOTO   367
0365:  CLRF   77
0366:  GOTO   36F
0367:  BCF    03.0
0368:  BTFSC  78.7
0369:  GOTO   36E
036A:  RLF    79,F
036B:  RLF    78,F
036C:  DECF   77,F
036D:  GOTO   367
036E:  BCF    78.7
036F:  RETURN
0370:  MOVLW  80
0371:  BTFSC  03.1
0372:  XORWF  42,F
0373:  CLRF   47
0374:  CLRF   48
0375:  MOVF   3E,W
0376:  MOVWF  46
0377:  MOVF   42,W
0378:  XORWF  46,F
0379:  MOVF   3D,W
037A:  BTFSC  03.2
037B:  GOTO   460
037C:  MOVWF  45
037D:  MOVWF  77
037E:  MOVF   41,W
037F:  BTFSC  03.2
0380:  GOTO   469
0381:  SUBWF  45,F
0382:  BTFSC  03.2
0383:  GOTO   405
0384:  BTFSS  03.0
0385:  GOTO   3C3
0386:  MOVF   42,W
0387:  MOVWF  4B
0388:  BSF    4B.7
0389:  MOVF   43,W
038A:  MOVWF  4A
038B:  MOVF   44,W
038C:  MOVWF  49
038D:  CLRF   48
038E:  BCF    03.0
038F:  RRF    4B,F
0390:  RRF    4A,F
0391:  RRF    49,F
0392:  RRF    48,F
0393:  DECFSZ 45,F
0394:  GOTO   38D
0395:  BTFSS  46.7
0396:  GOTO   39A
0397:  BSF    47.0
0398:  GOTO   47D
0399:  BCF    47.0
039A:  BCF    45.0
039B:  BSF    47.4
039C:  MOVLW  40
039D:  MOVWF  04
039E:  BCF    03.7
039F:  GOTO   492
03A0:  BCF    47.4
03A1:  BTFSC  46.7
03A2:  GOTO   3AD
03A3:  BTFSS  45.0
03A4:  GOTO   3B8
03A5:  RRF    4B,F
03A6:  RRF    4A,F
03A7:  RRF    49,F
03A8:  RRF    48,F
03A9:  INCF   77,F
03AA:  BTFSC  03.2
03AB:  GOTO   478
03AC:  GOTO   3B8
03AD:  BTFSC  4B.7
03AE:  GOTO   3BB
03AF:  BCF    03.0
03B0:  RLF    48,F
03B1:  RLF    49,F
03B2:  RLF    4A,F
03B3:  RLF    4B,F
03B4:  DECF   77,F
03B5:  BTFSC  03.2
03B6:  GOTO   478
03B7:  GOTO   3AD
03B8:  BSF    47.6
03B9:  GOTO   425
03BA:  BCF    47.6
03BB:  MOVF   3E,W
03BC:  MOVWF  46
03BD:  BTFSS  46.7
03BE:  GOTO   3C1
03BF:  BSF    4B.7
03C0:  GOTO   471
03C1:  BCF    4B.7
03C2:  GOTO   471
03C3:  MOVF   41,W
03C4:  MOVWF  45
03C5:  MOVWF  77
03C6:  MOVF   3D,W
03C7:  SUBWF  45,F
03C8:  MOVF   3E,W
03C9:  MOVWF  4B
03CA:  BSF    4B.7
03CB:  MOVF   3F,W
03CC:  MOVWF  4A
03CD:  MOVF   40,W
03CE:  MOVWF  49
03CF:  CLRF   48
03D0:  BCF    03.0
03D1:  RRF    4B,F
03D2:  RRF    4A,F
03D3:  RRF    49,F
03D4:  RRF    48,F
03D5:  DECFSZ 45,F
03D6:  GOTO   3CF
03D7:  BTFSS  46.7
03D8:  GOTO   3DC
03D9:  BSF    47.1
03DA:  GOTO   47D
03DB:  BCF    47.1
03DC:  BCF    45.0
03DD:  BSF    47.5
03DE:  MOVLW  44
03DF:  MOVWF  04
03E0:  BCF    03.7
03E1:  GOTO   492
03E2:  BCF    47.5
03E3:  BTFSC  46.7
03E4:  GOTO   3EF
03E5:  BTFSS  45.0
03E6:  GOTO   3FA
03E7:  RRF    4B,F
03E8:  RRF    4A,F
03E9:  RRF    49,F
03EA:  RRF    48,F
03EB:  INCF   77,F
03EC:  BTFSC  03.2
03ED:  GOTO   478
03EE:  GOTO   3FA
03EF:  BTFSC  4B.7
03F0:  GOTO   3FD
03F1:  BCF    03.0
03F2:  RLF    48,F
03F3:  RLF    49,F
03F4:  RLF    4A,F
03F5:  RLF    4B,F
03F6:  DECF   77,F
03F7:  BTFSC  03.2
03F8:  GOTO   478
03F9:  GOTO   3EF
03FA:  BSF    47.7
03FB:  GOTO   425
03FC:  BCF    47.7
03FD:  MOVF   42,W
03FE:  MOVWF  46
03FF:  BTFSS  46.7
0400:  GOTO   403
0401:  BSF    4B.7
0402:  GOTO   471
0403:  BCF    4B.7
0404:  GOTO   471
0405:  MOVF   42,W
0406:  MOVWF  4B
0407:  BSF    4B.7
0408:  MOVF   43,W
0409:  MOVWF  4A
040A:  MOVF   44,W
040B:  MOVWF  49
040C:  BTFSS  46.7
040D:  GOTO   412
040E:  BCF    4B.7
040F:  BSF    47.2
0410:  GOTO   47D
0411:  BCF    47.2
0412:  CLRF   48
0413:  BCF    45.0
0414:  MOVLW  40
0415:  MOVWF  04
0416:  BCF    03.7
0417:  GOTO   492
0418:  BTFSC  46.7
0419:  GOTO   43B
041A:  MOVF   3E,W
041B:  MOVWF  46
041C:  BTFSS  45.0
041D:  GOTO   425
041E:  RRF    4B,F
041F:  RRF    4A,F
0420:  RRF    49,F
0421:  RRF    48,F
0422:  INCF   77,F
0423:  BTFSC  03.2
0424:  GOTO   478
0425:  BTFSS  48.7
0426:  GOTO   436
0427:  INCF   49,F
0428:  BTFSS  03.2
0429:  GOTO   436
042A:  INCF   4A,F
042B:  BTFSS  03.2
042C:  GOTO   436
042D:  INCF   4B,F
042E:  BTFSS  03.2
042F:  GOTO   436
0430:  RRF    4B,F
0431:  RRF    4A,F
0432:  RRF    49,F
0433:  INCF   77,F
0434:  BTFSC  03.2
0435:  GOTO   478
0436:  BTFSC  47.6
0437:  GOTO   3BA
0438:  BTFSC  47.7
0439:  GOTO   3FC
043A:  GOTO   45A
043B:  MOVLW  80
043C:  XORWF  4B,F
043D:  BTFSS  4B.7
043E:  GOTO   443
043F:  GOTO   47D
0440:  MOVF   42,W
0441:  MOVWF  46
0442:  GOTO   450
0443:  MOVF   3E,W
0444:  MOVWF  46
0445:  MOVF   4B,F
0446:  BTFSS  03.2
0447:  GOTO   450
0448:  MOVF   4A,F
0449:  BTFSS  03.2
044A:  GOTO   450
044B:  MOVF   49,F
044C:  BTFSS  03.2
044D:  GOTO   450
044E:  CLRF   77
044F:  GOTO   471
0450:  BTFSC  4B.7
0451:  GOTO   45A
0452:  BCF    03.0
0453:  RLF    48,F
0454:  RLF    49,F
0455:  RLF    4A,F
0456:  RLF    4B,F
0457:  DECFSZ 77,F
0458:  GOTO   450
0459:  GOTO   478
045A:  BTFSS  46.7
045B:  GOTO   45E
045C:  BSF    4B.7
045D:  GOTO   471
045E:  BCF    4B.7
045F:  GOTO   471
0460:  MOVF   41,W
0461:  MOVWF  77
0462:  MOVF   42,W
0463:  MOVWF  4B
0464:  MOVF   43,W
0465:  MOVWF  4A
0466:  MOVF   44,W
0467:  MOVWF  49
0468:  GOTO   471
0469:  MOVF   3D,W
046A:  MOVWF  77
046B:  MOVF   3E,W
046C:  MOVWF  4B
046D:  MOVF   3F,W
046E:  MOVWF  4A
046F:  MOVF   40,W
0470:  MOVWF  49
0471:  MOVF   4B,W
0472:  MOVWF  78
0473:  MOVF   4A,W
0474:  MOVWF  79
0475:  MOVF   49,W
0476:  MOVWF  7A
0477:  GOTO   4B0
0478:  CLRF   77
0479:  CLRF   78
047A:  CLRF   79
047B:  CLRF   7A
047C:  GOTO   4B0
047D:  CLRF   48
047E:  COMF   49,F
047F:  COMF   4A,F
0480:  COMF   4B,F
0481:  COMF   48,F
0482:  INCF   48,F
0483:  BTFSS  03.2
0484:  GOTO   48B
0485:  INCF   49,F
0486:  BTFSS  03.2
0487:  GOTO   48B
0488:  INCF   4A,F
0489:  BTFSC  03.2
048A:  INCF   4B,F
048B:  BTFSC  47.0
048C:  GOTO   399
048D:  BTFSC  47.1
048E:  GOTO   3DB
048F:  BTFSC  47.2
0490:  GOTO   411
0491:  GOTO   440
0492:  MOVF   00,W
0493:  ADDWF  49,F
0494:  BTFSS  03.0
0495:  GOTO   49C
0496:  INCF   4A,F
0497:  BTFSS  03.2
0498:  GOTO   49C
0499:  INCF   4B,F
049A:  BTFSC  03.2
049B:  BSF    45.0
049C:  DECF   04,F
049D:  MOVF   00,W
049E:  ADDWF  4A,F
049F:  BTFSS  03.0
04A0:  GOTO   4A4
04A1:  INCF   4B,F
04A2:  BTFSC  03.2
04A3:  BSF    45.0
04A4:  DECF   04,F
04A5:  MOVF   00,W
04A6:  BTFSS  00.7
04A7:  XORLW  80
04A8:  ADDWF  4B,F
04A9:  BTFSC  03.0
04AA:  BSF    45.0
04AB:  BTFSC  47.4
04AC:  GOTO   3A0
04AD:  BTFSC  47.5
04AE:  GOTO   3E2
04AF:  GOTO   418
04B0:  RETURN
04B1:  MOVF   3D,W
04B2:  BTFSC  03.2
04B3:  GOTO   576
04B4:  MOVWF  49
04B5:  MOVF   41,W
04B6:  BTFSC  03.2
04B7:  GOTO   576
04B8:  SUBWF  49,F
04B9:  BTFSS  03.0
04BA:  GOTO   4C0
04BB:  MOVLW  7F
04BC:  ADDWF  49,F
04BD:  BTFSC  03.0
04BE:  GOTO   576
04BF:  GOTO   4C6
04C0:  MOVLW  81
04C1:  SUBWF  49,F
04C2:  BTFSS  03.0
04C3:  GOTO   576
04C4:  BTFSC  03.2
04C5:  GOTO   576
04C6:  MOVF   49,W
04C7:  MOVWF  77
04C8:  CLRF   78
04C9:  CLRF   79
04CA:  CLRF   7A
04CB:  CLRF   48
04CC:  MOVF   3E,W
04CD:  MOVWF  47
04CE:  BSF    47.7
04CF:  MOVF   3F,W
04D0:  MOVWF  46
04D1:  MOVF   40,W
04D2:  MOVWF  45
04D3:  MOVLW  19
04D4:  MOVWF  49
04D5:  MOVF   44,W
04D6:  SUBWF  45,F
04D7:  BTFSC  03.0
04D8:  GOTO   4E9
04D9:  MOVLW  01
04DA:  SUBWF  46,F
04DB:  BTFSC  03.0
04DC:  GOTO   4E9
04DD:  SUBWF  47,F
04DE:  BTFSC  03.0
04DF:  GOTO   4E9
04E0:  SUBWF  48,F
04E1:  BTFSC  03.0
04E2:  GOTO   4E9
04E3:  INCF   48,F
04E4:  INCF   47,F
04E5:  INCF   46,F
04E6:  MOVF   44,W
04E7:  ADDWF  45,F
04E8:  GOTO   51B
04E9:  MOVF   43,W
04EA:  SUBWF  46,F
04EB:  BTFSC  03.0
04EC:  GOTO   504
04ED:  MOVLW  01
04EE:  SUBWF  47,F
04EF:  BTFSC  03.0
04F0:  GOTO   504
04F1:  SUBWF  48,F
04F2:  BTFSC  03.0
04F3:  GOTO   504
04F4:  INCF   48,F
04F5:  INCF   47,F
04F6:  MOVF   43,W
04F7:  ADDWF  46,F
04F8:  MOVF   44,W
04F9:  ADDWF  45,F
04FA:  BTFSS  03.0
04FB:  GOTO   51B
04FC:  INCF   46,F
04FD:  BTFSS  03.2
04FE:  GOTO   51B
04FF:  INCF   47,F
0500:  BTFSS  03.2
0501:  GOTO   51B
0502:  INCF   48,F
0503:  GOTO   51B
0504:  MOVF   42,W
0505:  IORLW  80
0506:  SUBWF  47,F
0507:  BTFSC  03.0
0508:  GOTO   51A
0509:  MOVLW  01
050A:  SUBWF  48,F
050B:  BTFSC  03.0
050C:  GOTO   51A
050D:  INCF   48,F
050E:  MOVF   42,W
050F:  IORLW  80
0510:  ADDWF  47,F
0511:  MOVF   43,W
0512:  ADDWF  46,F
0513:  BTFSS  03.0
0514:  GOTO   4F8
0515:  INCF   47,F
0516:  BTFSS  03.2
0517:  GOTO   4F8
0518:  INCF   48,F
0519:  GOTO   4F8
051A:  BSF    7A.0
051B:  DECFSZ 49,F
051C:  GOTO   51E
051D:  GOTO   529
051E:  BCF    03.0
051F:  RLF    45,F
0520:  RLF    46,F
0521:  RLF    47,F
0522:  RLF    48,F
0523:  BCF    03.0
0524:  RLF    7A,F
0525:  RLF    79,F
0526:  RLF    78,F
0527:  RLF    4A,F
0528:  GOTO   4D5
0529:  BTFSS  4A.0
052A:  GOTO   531
052B:  BCF    03.0
052C:  RRF    78,F
052D:  RRF    79,F
052E:  RRF    7A,F
052F:  RRF    4A,F
0530:  GOTO   534
0531:  DECF   77,F
0532:  BTFSC  03.2
0533:  GOTO   576
0534:  BTFSC  4A.7
0535:  GOTO   55D
0536:  BCF    03.0
0537:  RLF    45,F
0538:  RLF    46,F
0539:  RLF    47,F
053A:  RLF    48,F
053B:  MOVF   44,W
053C:  SUBWF  45,F
053D:  BTFSC  03.0
053E:  GOTO   549
053F:  MOVLW  01
0540:  SUBWF  46,F
0541:  BTFSC  03.0
0542:  GOTO   549
0543:  SUBWF  47,F
0544:  BTFSC  03.0
0545:  GOTO   549
0546:  SUBWF  48,F
0547:  BTFSS  03.0
0548:  GOTO   56C
0549:  MOVF   43,W
054A:  SUBWF  46,F
054B:  BTFSC  03.0
054C:  GOTO   554
054D:  MOVLW  01
054E:  SUBWF  47,F
054F:  BTFSC  03.0
0550:  GOTO   554
0551:  SUBWF  48,F
0552:  BTFSS  03.0
0553:  GOTO   56C
0554:  MOVF   42,W
0555:  IORLW  80
0556:  SUBWF  47,F
0557:  BTFSC  03.0
0558:  GOTO   55D
0559:  MOVLW  01
055A:  SUBWF  48,F
055B:  BTFSS  03.0
055C:  GOTO   56C
055D:  INCF   7A,F
055E:  BTFSS  03.2
055F:  GOTO   56C
0560:  INCF   79,F
0561:  BTFSS  03.2
0562:  GOTO   56C
0563:  INCF   78,F
0564:  BTFSS  03.2
0565:  GOTO   56C
0566:  INCF   77,F
0567:  BTFSC  03.2
0568:  GOTO   576
0569:  RRF    78,F
056A:  RRF    79,F
056B:  RRF    7A,F
056C:  MOVF   3E,W
056D:  MOVWF  49
056E:  MOVF   42,W
056F:  XORWF  49,F
0570:  BTFSS  49.7
0571:  GOTO   574
0572:  BSF    78.7
0573:  GOTO   57A
0574:  BCF    78.7
0575:  GOTO   57A
0576:  CLRF   77
0577:  CLRF   78
0578:  CLRF   79
0579:  CLRF   7A
057A:  RETURN
057B:  MOVLW  8E
057C:  MOVWF  77
057D:  MOVF   3C,W
057E:  SUBWF  77,F
057F:  MOVF   3D,W
0580:  MOVWF  79
0581:  MOVF   3E,W
0582:  MOVWF  78
0583:  BSF    79.7
0584:  MOVF   77,F
0585:  BTFSC  03.2
0586:  GOTO   592
0587:  BCF    03.0
0588:  MOVF   79,F
0589:  BTFSS  03.2
058A:  GOTO   58E
058B:  MOVF   78,F
058C:  BTFSC  03.2
058D:  GOTO   592
058E:  RRF    79,F
058F:  RRF    78,F
0590:  DECFSZ 77,F
0591:  GOTO   587
0592:  BTFSS  3D.7
0593:  GOTO   599
0594:  COMF   78,F
0595:  COMF   79,F
0596:  INCF   78,F
0597:  BTFSC  03.2
0598:  INCF   79,F
0599:  RETURN
*
0676:  MOVF   3C,W
0677:  BTFSC  03.2
0678:  GOTO   6E6
0679:  MOVWF  44
067A:  MOVF   40,W
067B:  BTFSC  03.2
067C:  GOTO   6E6
067D:  ADDWF  44,F
067E:  BTFSC  03.0
067F:  GOTO   687
0680:  MOVLW  7F
0681:  SUBWF  44,F
0682:  BTFSS  03.0
0683:  GOTO   6E6
0684:  BTFSC  03.2
0685:  GOTO   6E6
0686:  GOTO   68B
0687:  MOVLW  81
0688:  ADDWF  44,F
0689:  BTFSC  03.0
068A:  GOTO   6E6
068B:  MOVF   44,W
068C:  MOVWF  77
068D:  CLRF   78
068E:  CLRF   79
068F:  CLRF   7A
0690:  MOVF   3D,W
0691:  MOVWF  48
0692:  BSF    48.7
0693:  MOVF   3E,W
0694:  MOVWF  47
0695:  MOVF   3F,W
0696:  MOVWF  46
0697:  MOVLW  18
0698:  MOVWF  44
0699:  CLRF   45
069A:  BTFSS  46.0
069B:  GOTO   6B4
069C:  MOVF   43,W
069D:  ADDWF  7A,F
069E:  BTFSS  03.0
069F:  GOTO   6A6
06A0:  INCF   79,F
06A1:  BTFSS  03.2
06A2:  GOTO   6A6
06A3:  INCF   78,F
06A4:  BTFSC  03.2
06A5:  BSF    45.7
06A6:  MOVF   42,W
06A7:  ADDWF  79,F
06A8:  BTFSS  03.0
06A9:  GOTO   6AD
06AA:  INCF   78,F
06AB:  BTFSC  03.2
06AC:  BSF    45.7
06AD:  MOVF   41,W
06AE:  MOVWF  3E
06AF:  BSF    3E.7
06B0:  MOVF   3E,W
06B1:  ADDWF  78,F
06B2:  BTFSC  03.0
06B3:  BSF    45.7
06B4:  RLF    45,F
06B5:  RRF    78,F
06B6:  RRF    79,F
06B7:  RRF    7A,F
06B8:  RRF    48,F
06B9:  RRF    47,F
06BA:  RRF    46,F
06BB:  BCF    03.0
06BC:  DECFSZ 44,F
06BD:  GOTO   699
06BE:  MOVLW  01
06BF:  ADDWF  77,F
06C0:  BTFSC  03.0
06C1:  GOTO   6E6
06C2:  BTFSC  78.7
06C3:  GOTO   6CB
06C4:  RLF    48,F
06C5:  RLF    7A,F
06C6:  RLF    79,F
06C7:  RLF    78,F
06C8:  DECF   77,F
06C9:  BTFSC  03.2
06CA:  GOTO   6E6
06CB:  BTFSS  48.7
06CC:  GOTO   6DC
06CD:  INCF   7A,F
06CE:  BTFSS  03.2
06CF:  GOTO   6DC
06D0:  INCF   79,F
06D1:  BTFSS  03.2
06D2:  GOTO   6DC
06D3:  INCF   78,F
06D4:  BTFSS  03.2
06D5:  GOTO   6DC
06D6:  RRF    78,F
06D7:  RRF    79,F
06D8:  RRF    7A,F
06D9:  INCF   77,F
06DA:  BTFSC  03.2
06DB:  GOTO   6E6
06DC:  MOVF   3D,W
06DD:  MOVWF  45
06DE:  MOVF   41,W
06DF:  XORWF  45,F
06E0:  BTFSS  45.7
06E1:  GOTO   6E4
06E2:  BSF    78.7
06E3:  GOTO   6EA
06E4:  BCF    78.7
06E5:  GOTO   6EA
06E6:  CLRF   77
06E7:  CLRF   78
06E8:  CLRF   79
06E9:  CLRF   7A
*
0718:  CLRF   78
0719:  CLRF   79
071A:  CLRF   77
071B:  CLRF   7A
071C:  MOVF   39,W
071D:  BTFSS  03.2
071E:  GOTO   722
071F:  MOVF   38,W
0720:  BTFSC  03.2
0721:  GOTO   73C
0722:  MOVLW  10
0723:  MOVWF  3A
0724:  BCF    03.0
0725:  RLF    36,F
0726:  RLF    37,F
0727:  RLF    77,F
0728:  RLF    7A,F
0729:  MOVF   39,W
072A:  SUBWF  7A,W
072B:  BTFSS  03.2
072C:  GOTO   72F
072D:  MOVF   38,W
072E:  SUBWF  77,W
072F:  BTFSS  03.0
0730:  GOTO   738
0731:  MOVF   38,W
0732:  SUBWF  77,F
0733:  BTFSS  03.0
0734:  DECF   7A,F
0735:  MOVF   39,W
0736:  SUBWF  7A,F
0737:  BSF    03.0
0738:  RLF    78,F
0739:  RLF    79,F
073A:  DECFSZ 3A,F
073B:  GOTO   724
073C:  RETURN
*
0800:  MOVF   0B,W
0801:  MOVWF  35
0802:  BCF    0B.7
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BSF    0C.7
0806:  BSF    0C.0
0807:  NOP
0808:  NOP
0809:  BCF    03.5
080A:  BCF    03.6
080B:  BTFSC  35.7
080C:  BSF    0B.7
080D:  BTFSC  03.0
080E:  GOTO   03B
080F:  BSF    03.6
0810:  MOVF   0C,W
0811:  ANDLW  7F
0812:  BCF    03.6
0813:  MOVWF  35
0814:  BSF    03.6
0815:  MOVF   0D,W
0816:  BCF    03.6
0817:  MOVWF  36
0818:  BSF    03.6
0819:  MOVF   0F,W
081A:  BCF    03.6
081B:  MOVWF  37
081C:  MOVF   35,W
081D:  BSF    03.5
081E:  MOVWF  5E
081F:  BCF    0A.3
0820:  BCF    03.5
0821:  CALL   182
0822:  BSF    0A.3
0823:  MOVF   36,W
0824:  BSF    03.6
0825:  MOVWF  0D
0826:  BCF    03.6
0827:  MOVF   37,W
0828:  BSF    03.6
0829:  MOVWF  0F
082A:  BCF    03.6
082B:  MOVF   0B,W
082C:  MOVWF  38
082D:  BCF    0B.7
082E:  BSF    03.5
082F:  BSF    03.6
0830:  BSF    0C.7
0831:  BSF    0C.0
0832:  NOP
0833:  NOP
0834:  BCF    03.5
0835:  BCF    03.6
0836:  BTFSC  38.7
0837:  BSF    0B.7
0838:  DECFSZ 34,F
0839:  GOTO   03B
083A:  GOTO   05E
083B:  BSF    03.6
083C:  RLF    0C,W
083D:  RLF    0E,W
083E:  ANDLW  7F
083F:  BCF    03.6
0840:  MOVWF  35
0841:  BSF    03.6
0842:  MOVF   0D,W
0843:  BCF    03.6
0844:  MOVWF  36
0845:  BSF    03.6
0846:  MOVF   0F,W
0847:  BCF    03.6
0848:  MOVWF  37
0849:  MOVF   35,W
084A:  BSF    03.5
084B:  MOVWF  5E
084C:  BCF    0A.3
084D:  BCF    03.5
084E:  CALL   182
084F:  BSF    0A.3
0850:  MOVF   36,W
0851:  BSF    03.6
0852:  MOVWF  0D
0853:  BCF    03.6
0854:  MOVF   37,W
0855:  BSF    03.6
0856:  MOVWF  0F
0857:  INCF   0D,F
0858:  BTFSC  03.2
0859:  INCF   0F,F
085A:  BCF    03.0
085B:  BCF    03.6
085C:  DECFSZ 34,F
085D:  GOTO   000
085E:  RETURN
085F:  MOVF   3B,W
0860:  CLRF   78
0861:  SUBWF  3A,W
0862:  BTFSC  03.0
0863:  GOTO   067
0864:  MOVF   3A,W
0865:  MOVWF  77
0866:  GOTO   073
0867:  CLRF   77
0868:  MOVLW  08
0869:  MOVWF  3C
086A:  RLF    3A,F
086B:  RLF    77,F
086C:  MOVF   3B,W
086D:  SUBWF  77,W
086E:  BTFSC  03.0
086F:  MOVWF  77
0870:  RLF    78,F
0871:  DECFSZ 3C,F
0872:  GOTO   06A
0873:  RETURN
0874:  MOVLW  20
0875:  BTFSS  35.4
0876:  MOVLW  30
0877:  MOVWF  36
0878:  MOVF   34,W
0879:  MOVWF  77
087A:  BTFSS  34.7
087B:  GOTO   084
087C:  COMF   77,F
087D:  INCF   77,F
087E:  MOVF   77,W
087F:  MOVWF  34
0880:  MOVLW  2D
0881:  MOVWF  36
0882:  BSF    35.7
0883:  BSF    35.0
0884:  MOVF   34,W
0885:  MOVWF  3A
0886:  MOVLW  64
0887:  MOVWF  3B
0888:  CALL   05F
0889:  MOVF   77,W
088A:  MOVWF  34
088B:  MOVLW  30
088C:  ADDWF  78,W
088D:  MOVWF  37
088E:  MOVF   34,W
088F:  MOVWF  3A
0890:  MOVLW  0A
0891:  MOVWF  3B
0892:  CALL   05F
0893:  MOVLW  30
0894:  ADDWF  77,W
0895:  MOVWF  39
0896:  MOVLW  30
0897:  ADDWF  78,W
0898:  MOVWF  38
0899:  MOVF   36,W
089A:  MOVWF  77
089B:  MOVLW  30
089C:  SUBWF  37,W
089D:  BTFSC  03.2
089E:  GOTO   0A3
089F:  BSF    35.1
08A0:  BTFSC  35.7
08A1:  BSF    35.2
08A2:  GOTO   0B7
08A3:  MOVF   36,W
08A4:  MOVWF  37
08A5:  MOVLW  20
08A6:  MOVWF  36
08A7:  MOVLW  30
08A8:  SUBWF  38,W
08A9:  BTFSC  03.2
08AA:  GOTO   0AF
08AB:  BSF    35.0
08AC:  BTFSC  35.7
08AD:  BSF    35.1
08AE:  GOTO   0B7
08AF:  BTFSS  03.2
08B0:  BSF    35.0
08B1:  BTFSS  03.2
08B2:  GOTO   0B7
08B3:  MOVF   37,W
08B4:  MOVWF  38
08B5:  MOVLW  20
08B6:  MOVWF  37
08B7:  BTFSC  35.2
08B8:  GOTO   0BE
08B9:  BTFSC  35.1
08BA:  GOTO   0C5
08BB:  BTFSC  35.0
08BC:  GOTO   0CC
08BD:  GOTO   0D3
08BE:  MOVF   36,W
08BF:  BSF    03.5
08C0:  MOVWF  5E
08C1:  BCF    0A.3
08C2:  BCF    03.5
08C3:  CALL   182
08C4:  BSF    0A.3
08C5:  MOVF   37,W
08C6:  BSF    03.5
08C7:  MOVWF  5E
08C8:  BCF    0A.3
08C9:  BCF    03.5
08CA:  CALL   182
08CB:  BSF    0A.3
08CC:  MOVF   38,W
08CD:  BSF    03.5
08CE:  MOVWF  5E
08CF:  BCF    0A.3
08D0:  BCF    03.5
08D1:  CALL   182
08D2:  BSF    0A.3
08D3:  MOVF   39,W
08D4:  BSF    03.5
08D5:  MOVWF  5E
08D6:  BCF    0A.3
08D7:  BCF    03.5
08D8:  CALL   182
08D9:  BSF    0A.3
08DA:  RETURN
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #use delay(crystal=20000000)
.................... 
.................... #include <lcd.h>
.................... #define _lcd_h_
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #use delay(clock=20000000)
*
001F:  MOVLW  DF
0020:  MOVWF  04
0021:  BCF    03.7
0022:  MOVF   00,W
0023:  BTFSC  03.2
0024:  GOTO   032
0025:  MOVLW  06
0026:  MOVWF  78
0027:  CLRF   77
0028:  DECFSZ 77,F
0029:  GOTO   028
002A:  DECFSZ 78,F
002B:  GOTO   027
002C:  MOVLW  7B
002D:  MOVWF  77
002E:  DECFSZ 77,F
002F:  GOTO   02E
0030:  DECFSZ 00,F
0031:  GOTO   025
0032:  RETURN
.................... void lcd_init(void);             // Ham dung de khoi dong C.LCD.
.................... byte lcd_read_byte(void);         // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... byte lcd_read_nibble(void);         // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
.................... void lcd_send_byte(byte address, byte n);   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... void lcd_send_nibble(byte n);      // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... void lcd_gotoxy(byte x, byte y);   // Ham thiet lap vi tri ghi tren C.LCD.
.................... char lcd_getc(byte x, byte y);      // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... void lcd_putc(char c);            // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... // Khai bao bien.
.................... // Dinh nghia cac thong so.
.................... #define LCD_RS_PIN         PIN_B4   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN         PIN_B3
.................... #define LCD_ENABLE_PIN     PIN_B2
.................... #define LCD_DATA4          PIN_D7
.................... #define LCD_DATA5          PIN_D6
.................... #define LCD_DATA6          PIN_D5
.................... #define LCD_DATA7          PIN_D4
.................... 
.................... //!#define LCD_RS_PIN         PIN_C0   // Cac ket noi C.LCD voi vi dieu khien.
.................... //!#define LCD_RW_PIN         PIN_C1
.................... //!#define LCD_ENABLE_PIN     PIN_C2
.................... //!#define LCD_DATA4          PIN_C3
.................... //!#define LCD_DATA5          PIN_C4
.................... //!#define LCD_DATA6          PIN_C5
.................... //!#define LCD_DATA7          PIN_C6
.................... 
.................... /*
.................... #define LCD_RS_PIN         PIN_D1   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN      PIN_D2
.................... #define LCD_ENABLE_PIN  PIN_D3
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7  
.................... */
.................... #define lcd_output_enable(x)   output_bit(LCD_ENABLE_PIN, x)   // Lenh dieu khien chan LCD_ENABLE_PIN.
.................... #define lcd_enable_tris()   output_drive(LCD_ENABLE_PIN)
.................... 
.................... #define lcd_output_rs(x)   output_bit(LCD_RS_PIN, x)   // Lenh dieu khien chan LCD_RS_PIN.
.................... #define lcd_rs_tris()      output_drive(LCD_RS_PIN)
.................... 
.................... #define lcd_output_rw(x)   output_bit(LCD_RW_PIN, x)   // Lenh dieu khien chan LCD_RW_PIN
.................... #define lcd_rw_tris()      output_drive(LCD_RW_PIN)
.................... 
.................... #define lcd_line_one   0x00    // Dia chi RAM C.LCD cho hang thu 1.
.................... #define lcd_line_two   0x40    // Dia chi RAM C.LCD cho hang thu 2.
.................... #define lcd_line_three   0x14
.................... #define lcd_line_four   0x54
.................... #define LCD_TYPE 0x02           // Thong tin cau hinh C.LCD: 0x00=5x7, 0x01=5x10, 0x02=2 lines
.................... 
.................... // Dinh nghia cac hang so.
.................... byte const LCD_INIT_STRING[4] = {0x28 | (LCD_TYPE << 2), 0x0C, 0x01, 0x06};
....................         // Cac byte nay can thiet de gui toi C.LCD, dung de khoi dong cau hinh hoat dong cho C.LCD.
....................       // Byte 1: 0x20 | (LCD_TYPE << 2) - So bit du lieu giao tiep (DL), so dong hien thi (N), kieu ky tu (F).
....................       //         0 0 1 DL N F x x (DL: Data Length, N: Number Line, F: Font).
....................          // Truong hop 1: 0x20 - 4 bit / 1 dong / 5 x 7.
....................          // Truong hop 2: 0x24 - 4 bit / 1 dong / 5 x 10.
....................          // Truong hop 3: 0x28 - 4 bit / 2 dong / 5 x 7.
....................       // Byte 2: 0x0C - Dieu khien hien thi (Bat hien thi, tat con tro, tat nhap nhay con tro).
....................       //         0 0 0 0 1 D C B (D: Display, C: Cursor, B: Blink).
....................       // Byte 3: 0x01 - Xoa hien thi va tra con tro ve dau dong.
....................       // Byte 4: 0x06 - Dat che do dau vao (Che do tang dia chi, tat dich chuyen hien thi).
....................       //         0 0 0 0 0 1 I/D S (I/D: Increment/Decrement, S: Shift).
....................       // Byte 5: .... - Doi con tro / hien thi.
....................       //         0 0 0 1 S/C R/L x x (S/C: Screen/Cursor, R/L: Right/Left).
.................... 
.................... // ***************************************************
.................... void lcd_init(void)    // Ham dung de khoi dong C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte i;
.................... // Dinh nghia ham.
.................... output_drive(LCD_DATA4);   // Thiet lap chan port (Data) o che do ngo ra.
*
0119:  BSF    03.5
011A:  BCF    08.7
.................... output_drive(LCD_DATA5);
011B:  BCF    08.6
.................... output_drive(LCD_DATA6);
011C:  BCF    08.5
.................... output_drive(LCD_DATA7);
011D:  BCF    08.4
.................... 
.................... lcd_enable_tris();         // Thiet lap chan port (Control: EN, RS, RW) o che do ngo ra.
011E:  BCF    06.2
.................... lcd_rs_tris();
011F:  BCF    06.4
.................... lcd_rw_tris();
0120:  BCF    06.3
.................... 
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
0121:  BCF    03.5
0122:  BCF    06.4
0123:  BSF    03.5
0124:  BCF    06.4
.................... lcd_output_rw(0);         // RW = 0 - Ghi thong tin vao C.LCD.
0125:  BCF    03.5
0126:  BCF    06.3
0127:  BSF    03.5
0128:  BCF    06.3
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
0129:  BCF    03.5
012A:  BCF    06.2
012B:  BSF    03.5
012C:  BCF    06.2
.................... 
.................... delay_ms(15);   // Tao thoi gian tre 15ms (Thoi gian de LCD tu reset khi moi duoc cap nguon).
012D:  MOVLW  0F
012E:  MOVWF  5F
012F:  BCF    03.5
0130:  CALL   01F
.................... 
.................... for(i=1;i<=3;i++)         // Doan lenh khoi dong C.LCD o che do 8 bit duoc thuc hien 3 lan lien tiep
0131:  MOVLW  01
0132:  MOVWF  34
0133:  MOVF   34,W
0134:  SUBLW  03
0135:  BTFSS  03.0
0136:  GOTO   143
....................    {                  // tai thoi diem ban dau (de dam bao cho C.LCD hoat dong on dinh trong 
....................    lcd_send_nibble(0x03);    // truong hop khi cung cap nguon cho C.LCD ma dien ap nguon tang len cham).
0137:  MOVLW  03
0138:  BSF    03.5
0139:  MOVWF  66
013A:  BCF    03.5
013B:  CALL   051
....................    delay_ms(5);         // RS = 0, RW = 0, D7 - D4 = 0011 (0x03) -> DL = 1 (8 bit).
013C:  MOVLW  05
013D:  BSF    03.5
013E:  MOVWF  5F
013F:  BCF    03.5
0140:  CALL   01F
0141:  INCF   34,F
0142:  GOTO   133
....................    }                  // Do co BF (Busy Flag) chua kiem tra duoc trong thoi diem nay, nen phai 
....................                      // thuc hien 3 lan (xem luu do khoi dong C.LCD cua nha san xuat).
.................... 
.................... lcd_send_nibble(0x02);      // Doan lenh khoi dong C.LCD o che do 4 bit. Tu luc nay thi 4 bit cao duoc ghi
0143:  MOVLW  02
0144:  BSF    03.5
0145:  MOVWF  66
0146:  BCF    03.5
0147:  CALL   051
....................                      // ra truoc tien, sau do la 4 bit thap.
....................                      // RS = 0, RW = 0, D7 - D4 = 0010 (0x02) -> DL = 0 (4 bit).
....................                      // Co BF (Busy Flag) co the bat dau kiem tra duoc tu luc nay.
.................... 
.................... for(i=0;i<=3;i++)
0148:  CLRF   34
0149:  MOVF   34,W
014A:  SUBLW  03
014B:  BTFSS  03.0
014C:  GOTO   15A
....................    lcd_send_byte(0,LCD_INIT_STRING[i]);   // Goi ham truyen thong tin (lenh) sang C.LCD.
014D:  MOVF   34,W
014E:  CALL   004
014F:  MOVWF  35
0150:  BSF    03.5
0151:  CLRF   63
0152:  BCF    03.5
0153:  MOVF   35,W
0154:  BSF    03.5
0155:  MOVWF  64
0156:  BCF    03.5
0157:  CALL   0BC
0158:  INCF   34,F
0159:  GOTO   149
015A:  BSF    0A.3
015B:  BCF    0A.4
015C:  GOTO   1C2 (RETURN)
.................... }                                 // Lenh: Thiet lap cau hinh hoat dong cho C.LCD.
.................... 
.................... // ***************************************************
.................... byte lcd_read_byte(void)   // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte low,high;
.................... // Dinh nghia ham.
.................... output_float(LCD_DATA4);   // Thiet lap chan port o che do ngo vao.
*
00BF:  BSF    08.7
.................... output_float(LCD_DATA5);
00C0:  BSF    08.6
.................... output_float(LCD_DATA6);
00C1:  BSF    08.5
.................... output_float(LCD_DATA7);
00C2:  BSF    08.4
.................... 
.................... lcd_output_rw(1);         // RW = 1 - Doc thong tin tu C.LCD.
00C3:  BCF    03.5
00C4:  BSF    06.3
00C5:  BSF    03.5
00C6:  BCF    06.3
....................                   // Tien hanh doc 4 bit cao cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00C7:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
00C8:  BCF    03.5
00C9:  BSF    06.2
00CA:  BSF    03.5
00CB:  BCF    06.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00CC:  NOP
.................... high = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit cao).
00CD:  BCF    03.5
00CE:  CALL   089
00CF:  MOVF   78,W
00D0:  BSF    03.5
00D1:  MOVWF  66
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
00D2:  BCF    03.5
00D3:  BCF    06.2
00D4:  BSF    03.5
00D5:  BCF    06.2
....................                   // Tien hanh doc 4 bit thap cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00D6:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
00D7:  BCF    03.5
00D8:  BSF    06.2
00D9:  BSF    03.5
00DA:  BCF    06.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00DB:  NOP
.................... low = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit thap).
00DC:  BCF    03.5
00DD:  CALL   089
00DE:  MOVF   78,W
00DF:  BSF    03.5
00E0:  MOVWF  65
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
00E1:  BCF    03.5
00E2:  BCF    06.2
00E3:  BSF    03.5
00E4:  BCF    06.2
.................... 
.................... output_drive(LCD_DATA4);   // Thiet lap chan port o che do ngo ra.
00E5:  BCF    08.7
.................... output_drive(LCD_DATA5);
00E6:  BCF    08.6
.................... output_drive(LCD_DATA6);
00E7:  BCF    08.5
.................... output_drive(LCD_DATA7);
00E8:  BCF    08.4
.................... 
.................... return((high<<4) | low);   // Tra ve ket qua du lieu (dang 8 bit).
00E9:  SWAPF  66,W
00EA:  MOVWF  77
00EB:  MOVLW  F0
00EC:  ANDWF  77,F
00ED:  MOVF   77,W
00EE:  IORWF  65,W
00EF:  MOVWF  78
.................... }
.................... 
.................... // ***************************************************
.................... byte lcd_read_nibble(void)   // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
*
0089:  BSF    03.5
008A:  CLRF   67
.................... {
.................... // Khai bao bien.
.................... byte n = 0x00;   // Mac dinh gia tri ban dau cho noi chua se thong tin.
.................... // Dinh nghia ham.
.................... n |= input(LCD_DATA4);         // Doc lan luot cac bit tu bus du lieu.
008B:  BSF    08.7
008C:  MOVLW  00
008D:  BCF    03.5
008E:  BTFSC  08.7
008F:  MOVLW  01
0090:  BSF    03.5
0091:  IORWF  67,F
.................... n |= input(LCD_DATA5) << 1;
0092:  BSF    08.6
0093:  MOVLW  00
0094:  BCF    03.5
0095:  BTFSC  08.6
0096:  MOVLW  01
0097:  MOVWF  77
0098:  BCF    03.0
0099:  RLF    77,F
009A:  MOVF   77,W
009B:  BSF    03.5
009C:  IORWF  67,F
.................... n |= input(LCD_DATA6) << 2;
009D:  BSF    08.5
009E:  MOVLW  00
009F:  BCF    03.5
00A0:  BTFSC  08.5
00A1:  MOVLW  01
00A2:  MOVWF  77
00A3:  RLF    77,F
00A4:  RLF    77,F
00A5:  MOVLW  FC
00A6:  ANDWF  77,F
00A7:  MOVF   77,W
00A8:  BSF    03.5
00A9:  IORWF  67,F
.................... n |= input(LCD_DATA7) << 3;
00AA:  BSF    08.4
00AB:  MOVLW  00
00AC:  BCF    03.5
00AD:  BTFSC  08.4
00AE:  MOVLW  01
00AF:  MOVWF  77
00B0:  RLF    77,F
00B1:  RLF    77,F
00B2:  RLF    77,F
00B3:  MOVLW  F8
00B4:  ANDWF  77,F
00B5:  MOVF   77,W
00B6:  BSF    03.5
00B7:  IORWF  67,F
.................... 
.................... return(n);   // Tra ve ket qua doc duoc (data = 0000 xxxx).
00B8:  MOVF   67,W
00B9:  MOVWF  78
00BA:  BCF    03.5
00BB:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_byte(byte address, byte n)   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... {                                 // address = 0: Lenh / 1: Du lieu.
....................                                  // byte = Thong tin can gui (8 bit).
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham.  
.................... lcd_output_rs(0);      // RS = 0 - Databus = Bus lenh.
00BC:  BCF    06.4
00BD:  BSF    03.5
00BE:  BCF    06.4
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
*
00F0:  MOVF   78,W
00F1:  MOVWF  65
00F2:  BTFSC  65.7
00F3:  GOTO   0BF
.................... lcd_output_rs(address);   // RS = address - Databus = Bus lenh/du lieu.
00F4:  MOVF   63,F
00F5:  BTFSS  03.2
00F6:  GOTO   0FB
00F7:  BCF    03.5
00F8:  BCF    06.4
00F9:  GOTO   0FD
00FA:  BSF    03.5
00FB:  BCF    03.5
00FC:  BSF    06.4
00FD:  BSF    03.5
00FE:  BCF    06.4
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00FF:  NOP
.................... lcd_output_rw(0);      // RW = 0 - Ghi thong tin vao C.LCD.
0100:  BCF    03.5
0101:  BCF    06.3
0102:  BSF    03.5
0103:  BCF    06.3
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0104:  NOP
.................... lcd_output_enable(0);   // EN = 0 - Cam truy xuat C.LCD.
0105:  BCF    03.5
0106:  BCF    06.2
0107:  BSF    03.5
0108:  BCF    06.2
.................... lcd_send_nibble(n >> 4);   // Goi ham truyen 4 bit cao sang C.LCD.
0109:  SWAPF  64,W
010A:  MOVWF  65
010B:  MOVLW  0F
010C:  ANDWF  65,F
010D:  MOVF   65,W
010E:  MOVWF  66
010F:  BCF    03.5
0110:  CALL   051
.................... lcd_send_nibble(n & 0x0F);   // Goi ham truyen 4 bit thap sang C.LCD.
0111:  BSF    03.5
0112:  MOVF   64,W
0113:  ANDLW  0F
0114:  MOVWF  65
0115:  MOVWF  66
0116:  BCF    03.5
0117:  CALL   051
0118:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_nibble(byte n)   // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... {                        // n = Thong tin can gui. 4 bit can gui phai nam vi tri 4 bit thap.
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... output_bit(LCD_DATA4, bit_test(n, 0));   // Xuat lan luot cac bit len bus du lieu.
*
0051:  BSF    03.5
0052:  BTFSC  66.0
0053:  GOTO   058
0054:  BCF    03.5
0055:  BCF    08.7
0056:  GOTO   05A
0057:  BSF    03.5
0058:  BCF    03.5
0059:  BSF    08.7
005A:  BSF    03.5
005B:  BCF    08.7
.................... output_bit(LCD_DATA5, bit_test(n, 1));
005C:  BTFSC  66.1
005D:  GOTO   062
005E:  BCF    03.5
005F:  BCF    08.6
0060:  GOTO   064
0061:  BSF    03.5
0062:  BCF    03.5
0063:  BSF    08.6
0064:  BSF    03.5
0065:  BCF    08.6
.................... output_bit(LCD_DATA6, bit_test(n, 2));
0066:  BTFSC  66.2
0067:  GOTO   06C
0068:  BCF    03.5
0069:  BCF    08.5
006A:  GOTO   06E
006B:  BSF    03.5
006C:  BCF    03.5
006D:  BSF    08.5
006E:  BSF    03.5
006F:  BCF    08.5
.................... output_bit(LCD_DATA7, bit_test(n, 3));
0070:  BTFSC  66.3
0071:  GOTO   076
0072:  BCF    03.5
0073:  BCF    08.4
0074:  GOTO   078
0075:  BSF    03.5
0076:  BCF    03.5
0077:  BSF    08.4
0078:  BSF    03.5
0079:  BCF    08.4
....................     
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
007A:  NOP
.................... lcd_output_enable(1);   // Tao xung ghi thong tin vao C.LCD.
007B:  BCF    03.5
007C:  BSF    06.2
007D:  BSF    03.5
007E:  BCF    06.2
.................... delay_us(2);         // Tao tre 2 chu ky (t=2us voi fosc=4MHz).
007F:  MOVLW  03
0080:  MOVWF  77
0081:  DECFSZ 77,F
0082:  GOTO   081
.................... lcd_output_enable(0);   // Tao xung ghi thong tin vao LCD - EN = 1->0 (High to Low).
0083:  BCF    03.5
0084:  BCF    06.2
0085:  BSF    03.5
0086:  BCF    06.2
0087:  BCF    03.5
0088:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_gotoxy(byte x, byte y)   // Ham thiet lap vi tri ghi tren C.LCD (Goc tren ben trai co toa do la 1,1).
.................... {
.................... // Khai bao bien.
.................... byte address;
.................... // Dinh nghia ham.  
.................... if(y==1)               // Kiem tra vi tri truy xuat thuoc hang 2.
*
015D:  BSF    03.5
015E:  DECFSZ 60,W
015F:  GOTO   162
....................    address=lcd_line_one;      // Nap dia chi RAM cua hang 2. 
0160:  CLRF   61
0161:  GOTO   176
.................... else if(y==2)      // Neu vi tri truy xuat thuoc hang 1.
0162:  MOVF   60,W
0163:  SUBLW  02
0164:  BTFSS  03.2
0165:  GOTO   169
....................    address=lcd_line_two;      // Nap dia chi RAM cua hang 1.
0166:  MOVLW  40
0167:  MOVWF  61
0168:  GOTO   176
.................... else if(y==3)
0169:  MOVF   60,W
016A:  SUBLW  03
016B:  BTFSS  03.2
016C:  GOTO   170
....................    address=lcd_line_three;     
016D:  MOVLW  14
016E:  MOVWF  61
016F:  GOTO   176
.................... else if(y==4)
0170:  MOVF   60,W
0171:  SUBLW  04
0172:  BTFSS  03.2
0173:  GOTO   176
....................    address=lcd_line_four;   
0174:  MOVLW  54
0175:  MOVWF  61
.................... 
.................... address+=x-1;               // Ghep dia chi cot vao dia chi tong quat (address). address = address + (x-1).      
0176:  MOVLW  01
0177:  SUBWF  5F,W
0178:  ADDWF  61,F
....................                         // Ta qui uoc: Goc tren ben trai co toa do la 1,1 -> Cot dau tien la Cot 1
....................                         // (x-1) vi C.LCD qui uoc cot dau tien co dia chi la 0.
.................... lcd_send_byte(0,0x80|address);   // Goi ham truyen thong tin (lenh) sang C.LCD.
0179:  MOVF   61,W
017A:  IORLW  80
017B:  MOVWF  62
017C:  CLRF   63
017D:  MOVF   62,W
017E:  MOVWF  64
017F:  BCF    03.5
0180:  CALL   0BC
0181:  RETURN
.................... }                        // Lenh: Thiet lap dia chi DDRAM cua C.LCD (addresss).   
.................... 
.................... // ***************************************************
.................... char lcd_getc(byte x, byte y)   // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... char value;
.................... // Dinh nghia ham.  
.................... lcd_gotoxy(x,y);            // Xac dinh toa do C.LCD can truy xuat.
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
.................... lcd_output_rs(1);         // RS = 1 - Databus = Bus du lieu.
.................... value = lcd_read_byte();   // Doc ve tu C.LCD.
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
.................... 
.................... return(value);      // Tra ve ma ky tu tai toa do yeu cau.
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_putc(char c)   // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... switch (c)
0182:  BSF    03.5
0183:  MOVF   5E,W
0184:  XORLW  0C
0185:  BCF    03.5
0186:  BTFSC  03.2
0187:  GOTO   18F
0188:  XORLW  06
0189:  BTFSC  03.2
018A:  GOTO   19B
018B:  XORLW  02
018C:  BTFSC  03.2
018D:  GOTO   1A3
018E:  GOTO   1AA
....................    {
....................    case '\f':     // Chuc nang xoa hien thi.
....................       lcd_send_byte(0,0x01);   // Goi ham truyen thong tin (lenh) sang C.LCD.
018F:  BSF    03.5
0190:  CLRF   63
0191:  MOVLW  01
0192:  MOVWF  64
0193:  BCF    03.5
0194:  CALL   0BC
....................       delay_ms(2);         // Lenh: Xoa hien thi tren man hinh C.LCD (0x01).
0195:  MOVLW  02
0196:  BSF    03.5
0197:  MOVWF  5F
0198:  BCF    03.5
0199:  CALL   01F
....................       break;
019A:  GOTO   1B1
....................    case '\n':       // Chuc nang bat dau hang thu 2.
....................       lcd_gotoxy(1,0x02);     // Goi ham truyen thong tin (du lieu) sang C.LCD.   
019B:  MOVLW  01
019C:  BSF    03.5
019D:  MOVWF  5F
019E:  MOVLW  02
019F:  MOVWF  60
01A0:  BCF    03.5
01A1:  CALL   15D
....................       break;
01A2:  GOTO   1B1
....................     case '\b':       // Chuc nang lui ve 1 vi tri.
....................       lcd_send_byte(0,0x10);    // Goi ham truyen thong tin (lenh) sang C.LCD. 
01A3:  BSF    03.5
01A4:  CLRF   63
01A5:  MOVLW  10
01A6:  MOVWF  64
01A7:  BCF    03.5
01A8:  CALL   0BC
....................       break;               // Lenh: Doi con tro sang trai (0x10).
01A9:  GOTO   1B1
....................    default:       // Chuc nang hien thi ky tu c tai vi tri ke tiep tren C.LCD.
....................       lcd_send_byte(1,c);     // Goi ham truyen thong tin (du lieu) sang C.LCD.
01AA:  MOVLW  01
01AB:  BSF    03.5
01AC:  MOVWF  63
01AD:  MOVF   5E,W
01AE:  MOVWF  64
01AF:  BCF    03.5
01B0:  CALL   0BC
....................       break;
....................    }
01B1:  RETURN
.................... }      
.................... // ***************************************************   
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
02CF:  MOVF   5C,W
02D0:  MOVWF  5E
02D1:  MOVF   5B,W
02D2:  MOVWF  5D
02D3:  MOVF   5E,W
02D4:  MOVWF  7A
02D5:  MOVF   5D,W
02D6:  MOVWF  04
02D7:  BCF    03.7
02D8:  BTFSC  7A.0
02D9:  BSF    03.7
02DA:  MOVF   00,F
02DB:  BTFSC  03.2
02DC:  GOTO   2E1
02DD:  INCF   5D,F
02DE:  BTFSC  03.2
02DF:  INCF   5E,F
02E0:  GOTO   2D3
....................    return(sc - s);
02E1:  MOVF   5B,W
02E2:  SUBWF  5D,W
02E3:  MOVWF  77
02E4:  MOVF   5E,W
02E5:  MOVWF  7A
02E6:  MOVF   5C,W
02E7:  BTFSS  03.0
02E8:  INCFSZ 5C,W
02E9:  SUBWF  7A,F
02EA:  MOVF   77,W
02EB:  MOVWF  78
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
09BA:  BCF    03.5
09BB:  CLRF   20
09BC:  CLRF   21
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define ok       input(PIN_C2)
.................... #define up     input(PIN_C0)
.................... #define dw    input(PIN_C1)
.................... 
.................... #define BUZ PIN_C3
.................... 
.................... unsigned int16 so_ng, so_tp, lm35a_ng, lm35a_tp, lm35a_ngt=0, lm35;
.................... unsigned int gtmin = 30, gtmax = 32;
.................... int1 alarm = 1;
.................... 
.................... void float_to_ng_2so_tp(float st)                      
.................... {
....................    so_ng = st/1;       //nguyen
*
062E:  MOVF   3B,W
062F:  MOVWF  40
0630:  MOVF   3A,W
0631:  MOVWF  3F
0632:  MOVF   39,W
0633:  MOVWF  3E
0634:  MOVF   38,W
0635:  MOVWF  3D
0636:  CLRF   44
0637:  CLRF   43
0638:  CLRF   42
0639:  MOVLW  7F
063A:  MOVWF  41
063B:  CALL   4B1
063C:  MOVF   7A,W
063D:  MOVWF  3F
063E:  MOVF   79,W
063F:  MOVWF  3E
0640:  MOVF   78,W
0641:  MOVWF  3D
0642:  MOVF   77,W
0643:  MOVWF  3C
0644:  CALL   57B
0645:  MOVF   79,W
0646:  MOVWF  23
0647:  MOVF   78,W
0648:  MOVWF  22
....................    st = st-so_ng;      //tphan
0649:  MOVF   23,W
064A:  MOVWF  3E
064B:  MOVF   22,W
064C:  MOVWF  3D
064D:  CALL   353
064E:  BSF    03.1
064F:  MOVF   3B,W
0650:  MOVWF  40
0651:  MOVF   3A,W
0652:  MOVWF  3F
0653:  MOVF   39,W
0654:  MOVWF  3E
0655:  MOVF   38,W
0656:  MOVWF  3D
0657:  MOVF   7A,W
0658:  MOVWF  44
0659:  MOVF   79,W
065A:  MOVWF  43
065B:  MOVF   78,W
065C:  MOVWF  42
065D:  MOVF   77,W
065E:  MOVWF  41
065F:  CALL   370
0660:  MOVF   7A,W
0661:  MOVWF  3B
0662:  MOVF   79,W
0663:  MOVWF  3A
0664:  MOVF   78,W
0665:  MOVWF  39
0666:  MOVF   77,W
0667:  MOVWF  38
....................    st = st*100;
0668:  MOVF   3B,W
0669:  MOVWF  3F
066A:  MOVF   3A,W
066B:  MOVWF  3E
066C:  MOVF   39,W
066D:  MOVWF  3D
066E:  MOVF   38,W
066F:  MOVWF  3C
0670:  CLRF   43
0671:  CLRF   42
0672:  MOVLW  48
0673:  MOVWF  41
0674:  MOVLW  85
0675:  MOVWF  40
*
06EA:  MOVF   7A,W
06EB:  MOVWF  3B
06EC:  MOVF   79,W
06ED:  MOVWF  3A
06EE:  MOVF   78,W
06EF:  MOVWF  39
06F0:  MOVF   77,W
06F1:  MOVWF  38
....................    so_tp = st/1;
06F2:  MOVF   3B,W
06F3:  MOVWF  40
06F4:  MOVF   3A,W
06F5:  MOVWF  3F
06F6:  MOVF   39,W
06F7:  MOVWF  3E
06F8:  MOVF   38,W
06F9:  MOVWF  3D
06FA:  CLRF   44
06FB:  CLRF   43
06FC:  CLRF   42
06FD:  MOVLW  7F
06FE:  MOVWF  41
06FF:  CALL   4B1
0700:  MOVF   7A,W
0701:  MOVWF  3F
0702:  MOVF   79,W
0703:  MOVWF  3E
0704:  MOVF   78,W
0705:  MOVWF  3D
0706:  MOVF   77,W
0707:  MOVWF  3C
0708:  CALL   57B
0709:  MOVF   79,W
070A:  MOVWF  25
070B:  MOVF   78,W
070C:  MOVWF  24
.................... } 
.................... 
.................... float main_adc_read()                      
.................... {
....................    float kq_adc;  unsigned int8 i;
....................    set_adc_channel(0);
*
059A:  MOVLW  00
059B:  MOVWF  78
059C:  MOVF   1F,W
059D:  ANDLW  C7
059E:  IORWF  78,W
059F:  MOVWF  1F
....................    delay_us(20);
05A0:  MOVLW  21
05A1:  MOVWF  77
05A2:  DECFSZ 77,F
05A3:  GOTO   5A2
....................    kq_adc = 0;
05A4:  CLRF   3B
05A5:  CLRF   3A
05A6:  CLRF   39
05A7:  CLRF   38
....................    for(i=0;i<100;i++)
05A8:  CLRF   3C
05A9:  MOVF   3C,W
05AA:  SUBLW  63
05AB:  BTFSS  03.0
05AC:  GOTO   5D9
....................    {
....................       kq_adc = kq_adc + read_adc();   
05AD:  BSF    1F.2
05AE:  BTFSC  1F.2
05AF:  GOTO   5AE
05B0:  MOVF   1E,W
05B1:  MOVWF  79
05B2:  BSF    03.5
05B3:  MOVF   1E,W
05B4:  MOVWF  78
05B5:  MOVF   79,W
05B6:  MOVWF  7A
05B7:  MOVF   1E,W
05B8:  BCF    03.5
05B9:  MOVWF  3D
05BA:  MOVF   79,W
05BB:  MOVWF  3E
05BC:  CALL   353
05BD:  BCF    03.1
05BE:  MOVF   3B,W
05BF:  MOVWF  40
05C0:  MOVF   3A,W
05C1:  MOVWF  3F
05C2:  MOVF   39,W
05C3:  MOVWF  3E
05C4:  MOVF   38,W
05C5:  MOVWF  3D
05C6:  MOVF   7A,W
05C7:  MOVWF  44
05C8:  MOVF   79,W
05C9:  MOVWF  43
05CA:  MOVF   78,W
05CB:  MOVWF  42
05CC:  MOVF   77,W
05CD:  MOVWF  41
05CE:  CALL   370
05CF:  MOVF   7A,W
05D0:  MOVWF  3B
05D1:  MOVF   79,W
05D2:  MOVWF  3A
05D3:  MOVF   78,W
05D4:  MOVWF  39
05D5:  MOVF   77,W
05D6:  MOVWF  38
05D7:  INCF   3C,F
05D8:  GOTO   5A9
....................    }                                    
....................    kq_adc = kq_adc/100;
05D9:  MOVF   3B,W
05DA:  MOVWF  40
05DB:  MOVF   3A,W
05DC:  MOVWF  3F
05DD:  MOVF   39,W
05DE:  MOVWF  3E
05DF:  MOVF   38,W
05E0:  MOVWF  3D
05E1:  CLRF   44
05E2:  CLRF   43
05E3:  MOVLW  48
05E4:  MOVWF  42
05E5:  MOVLW  85
05E6:  MOVWF  41
05E7:  CALL   4B1
05E8:  MOVF   7A,W
05E9:  MOVWF  3B
05EA:  MOVF   79,W
05EB:  MOVWF  3A
05EC:  MOVF   78,W
05ED:  MOVWF  39
05EE:  MOVF   77,W
05EF:  MOVWF  38
....................    return kq_adc;
05F0:  MOVF   38,W
05F1:  MOVWF  77
05F2:  MOVF   39,W
05F3:  MOVWF  78
05F4:  MOVF   3A,W
05F5:  MOVWF  79
05F6:  MOVF   3B,W
05F7:  MOVWF  7A
.................... }
.................... 
.................... void doc_value_lm35() 
.................... {
....................    float lm35a;
....................    lm35a = main_adc_read();
05F8:  MOVF   7A,W
05F9:  MOVWF  37
05FA:  MOVF   79,W
05FB:  MOVWF  36
05FC:  MOVF   78,W
05FD:  MOVWF  35
05FE:  MOVF   77,W
05FF:  MOVWF  34
....................    lm35a = lm35a/2.046;
0600:  MOVF   37,W
0601:  MOVWF  40
0602:  MOVF   36,W
0603:  MOVWF  3F
0604:  MOVF   35,W
0605:  MOVWF  3E
0606:  MOVF   34,W
0607:  MOVWF  3D
0608:  MOVLW  AA
0609:  MOVWF  44
060A:  MOVLW  F1
060B:  MOVWF  43
060C:  MOVLW  02
060D:  MOVWF  42
060E:  MOVLW  80
060F:  MOVWF  41
0610:  CALL   4B1
0611:  MOVF   7A,W
0612:  MOVWF  37
0613:  MOVF   79,W
0614:  MOVWF  36
0615:  MOVF   78,W
0616:  MOVWF  35
0617:  MOVF   77,W
0618:  MOVWF  34
....................    lm35 = lm35a;
0619:  MOVF   37,W
061A:  MOVWF  3F
061B:  MOVF   36,W
061C:  MOVWF  3E
061D:  MOVF   35,W
061E:  MOVWF  3D
061F:  MOVF   34,W
0620:  MOVWF  3C
0621:  CALL   57B
0622:  MOVF   79,W
0623:  MOVWF  2D
0624:  MOVF   78,W
0625:  MOVWF  2C
....................    float_to_ng_2so_tp(lm35a);
0626:  MOVF   37,W
0627:  MOVWF  3B
0628:  MOVF   36,W
0629:  MOVWF  3A
062A:  MOVF   35,W
062B:  MOVWF  39
062C:  MOVF   34,W
062D:  MOVWF  38
....................    lm35a_ng = so_ng;
*
070D:  MOVF   23,W
070E:  MOVWF  27
070F:  MOVF   22,W
0710:  MOVWF  26
....................    lm35a_tp = so_tp;
0711:  MOVF   25,W
0712:  MOVWF  29
0713:  MOVF   24,W
0714:  MOVWF  28
0715:  BSF    0A.3
0716:  BCF    0A.4
0717:  GOTO   1E0 (RETURN)
.................... }
.................... 
.................... void xuly_alarm(){
....................    if(alarm == 1){
*
07CC:  BTFSS  30.0
07CD:  GOTO   7F1
....................       if(lm35 >= gtmax){
07CE:  MOVF   2D,F
07CF:  BTFSS  03.2
07D0:  GOTO   7D5
07D1:  MOVF   2F,W
07D2:  SUBWF  2C,W
07D3:  BTFSS  03.0
07D4:  GOTO   7DC
....................          output_high(BUZ);
07D5:  BCF    31.3
07D6:  MOVF   31,W
07D7:  BSF    03.5
07D8:  MOVWF  07
07D9:  BCF    03.5
07DA:  BSF    07.3
....................       }
07DB:  GOTO   7F0
....................       else if(lm35 <= gtmin){
07DC:  MOVF   2D,F
07DD:  BTFSS  03.2
07DE:  GOTO   7EA
07DF:  MOVF   2C,W
07E0:  SUBWF  2E,W
07E1:  BTFSS  03.0
07E2:  GOTO   7EA
....................          output_high(BUZ);
07E3:  BCF    31.3
07E4:  MOVF   31,W
07E5:  BSF    03.5
07E6:  MOVWF  07
07E7:  BCF    03.5
07E8:  BSF    07.3
....................       }
07E9:  GOTO   7F0
....................       else{
....................          output_low(BUZ);
07EA:  BCF    31.3
07EB:  MOVF   31,W
07EC:  BSF    03.5
07ED:  MOVWF  07
07EE:  BCF    03.5
07EF:  BCF    07.3
....................       }
....................    }
07F0:  GOTO   7F9
....................    else if(alarm == 0){
07F1:  BTFSC  30.0
07F2:  GOTO   7F9
....................       output_low(BUZ);
07F3:  BCF    31.3
07F4:  MOVF   31,W
07F5:  BSF    03.5
07F6:  MOVWF  07
07F7:  BCF    03.5
07F8:  BCF    07.3
....................    }
.................... }
.................... 
.................... void hienthi_lcd(int1 ht_ng, ht_tp){
....................    lcd_gotoxy(1,1);
*
073D:  MOVLW  01
073E:  BSF    03.5
073F:  MOVWF  5F
0740:  MOVWF  60
0741:  BCF    03.5
0742:  CALL   15D
....................    lcd_putc("Temp: ");
0743:  MOVLW  0C
0744:  BSF    03.6
0745:  MOVWF  0D
0746:  MOVLW  00
0747:  MOVWF  0F
0748:  BCF    03.6
0749:  CALL   1B2
....................    if(lm35a_ngt!=lm35a_ng)
074A:  MOVF   26,W
074B:  SUBWF  2A,W
074C:  BTFSS  03.2
074D:  GOTO   752
074E:  MOVF   27,W
074F:  SUBWF  2B,W
0750:  BTFSC  03.2
0751:  GOTO   7CC
....................    {
....................       lm35a_ngt=lm35a_ng;
0752:  MOVF   27,W
0753:  MOVWF  2B
0754:  MOVF   26,W
0755:  MOVWF  2A
....................       lcd_gotoxy(9, 1);
0756:  MOVLW  09
0757:  BSF    03.5
0758:  MOVWF  5F
0759:  MOVLW  01
075A:  MOVWF  60
075B:  BCF    03.5
075C:  CALL   15D
....................       lcd_putc(".");
075D:  MOVLW  10
075E:  BSF    03.6
075F:  MOVWF  0D
0760:  MOVLW  00
0761:  MOVWF  0F
0762:  BCF    03.6
0763:  CALL   1B2
....................       if(ht_ng){
0764:  MOVF   34,F
0765:  BTFSC  03.2
0766:  GOTO   798
....................          lcd_gotoxy(7,1);
0767:  MOVLW  07
0768:  BSF    03.5
0769:  MOVWF  5F
076A:  MOVLW  01
076B:  MOVWF  60
076C:  BCF    03.5
076D:  CALL   15D
....................          lcd_putc(lm35a_ng/10 + 0x30);
076E:  MOVF   27,W
076F:  MOVWF  37
0770:  MOVF   26,W
0771:  MOVWF  36
0772:  CLRF   39
0773:  MOVLW  0A
0774:  MOVWF  38
0775:  CALL   718
0776:  MOVF   79,W
0777:  MOVWF  37
0778:  MOVF   78,W
0779:  MOVWF  36
077A:  MOVLW  30
077B:  ADDWF  36,F
077C:  BTFSC  03.0
077D:  INCF   37,F
077E:  MOVF   36,W
077F:  BSF    03.5
0780:  MOVWF  5E
0781:  BCF    03.5
0782:  CALL   182
....................          lcd_putc(lm35a_ng%10 + 0x30);
0783:  MOVF   27,W
0784:  MOVWF  37
0785:  MOVF   26,W
0786:  MOVWF  36
0787:  CLRF   39
0788:  MOVLW  0A
0789:  MOVWF  38
078A:  CALL   718
078B:  MOVF   77,W
078C:  MOVWF  36
078D:  MOVF   7A,W
078E:  MOVWF  37
078F:  MOVLW  30
0790:  ADDWF  36,F
0791:  BTFSC  03.0
0792:  INCF   37,F
0793:  MOVF   36,W
0794:  BSF    03.5
0795:  MOVWF  5E
0796:  BCF    03.5
0797:  CALL   182
....................       }
....................       if(ht_tp){
0798:  MOVF   35,F
0799:  BTFSC  03.2
079A:  GOTO   7CC
....................          lcd_gotoxy(10,1);
079B:  MOVLW  0A
079C:  BSF    03.5
079D:  MOVWF  5F
079E:  MOVLW  01
079F:  MOVWF  60
07A0:  BCF    03.5
07A1:  CALL   15D
....................          lcd_putc(lm35a_tp/10 + 0x30);
07A2:  MOVF   29,W
07A3:  MOVWF  37
07A4:  MOVF   28,W
07A5:  MOVWF  36
07A6:  CLRF   39
07A7:  MOVLW  0A
07A8:  MOVWF  38
07A9:  CALL   718
07AA:  MOVF   79,W
07AB:  MOVWF  37
07AC:  MOVF   78,W
07AD:  MOVWF  36
07AE:  MOVLW  30
07AF:  ADDWF  36,F
07B0:  BTFSC  03.0
07B1:  INCF   37,F
07B2:  MOVF   36,W
07B3:  BSF    03.5
07B4:  MOVWF  5E
07B5:  BCF    03.5
07B6:  CALL   182
....................          lcd_putc(lm35a_tp%10 + 0x30);
07B7:  MOVF   29,W
07B8:  MOVWF  37
07B9:  MOVF   28,W
07BA:  MOVWF  36
07BB:  CLRF   39
07BC:  MOVLW  0A
07BD:  MOVWF  38
07BE:  CALL   718
07BF:  MOVF   77,W
07C0:  MOVWF  36
07C1:  MOVF   7A,W
07C2:  MOVWF  37
07C3:  MOVLW  30
07C4:  ADDWF  36,F
07C5:  BTFSC  03.0
07C6:  INCF   37,F
07C7:  MOVF   36,W
07C8:  BSF    03.5
07C9:  MOVWF  5E
07CA:  BCF    03.5
07CB:  CALL   182
....................      }
....................    }
....................    xuly_alarm();
*
07F9:  BSF    0A.3
07FA:  BCF    0A.4
07FB:  GOTO   1ED (RETURN)
.................... }
.................... 
.................... void hienthi_thongtin(void){
....................     char Tri[] = {"                LAM QUANG TRI-19151087                 "};
*
0226:  MOVLW  20
0227:  MOVWF  34
0228:  MOVWF  35
0229:  MOVWF  36
022A:  MOVWF  37
022B:  MOVWF  38
022C:  MOVWF  39
022D:  MOVWF  3A
022E:  MOVWF  3B
022F:  MOVWF  3C
0230:  MOVWF  3D
0231:  MOVWF  3E
0232:  MOVWF  3F
0233:  MOVWF  40
0234:  MOVWF  41
0235:  MOVWF  42
0236:  MOVWF  43
0237:  MOVLW  4C
0238:  MOVWF  44
0239:  MOVLW  41
023A:  MOVWF  45
023B:  MOVLW  4D
023C:  MOVWF  46
023D:  MOVLW  20
023E:  MOVWF  47
023F:  MOVLW  51
0240:  MOVWF  48
0241:  MOVLW  55
0242:  MOVWF  49
0243:  MOVLW  41
0244:  MOVWF  4A
0245:  MOVLW  4E
0246:  MOVWF  4B
0247:  MOVLW  47
0248:  MOVWF  4C
0249:  MOVLW  20
024A:  MOVWF  4D
024B:  MOVLW  54
024C:  MOVWF  4E
024D:  MOVLW  52
024E:  MOVWF  4F
024F:  MOVLW  49
0250:  MOVWF  50
0251:  MOVLW  2D
0252:  MOVWF  51
0253:  MOVLW  31
0254:  MOVWF  52
0255:  MOVLW  39
0256:  MOVWF  53
0257:  MOVLW  31
0258:  MOVWF  54
0259:  MOVLW  35
025A:  MOVWF  55
025B:  MOVLW  31
025C:  MOVWF  56
025D:  MOVLW  30
025E:  MOVWF  57
025F:  MOVLW  38
0260:  MOVWF  58
0261:  MOVLW  37
0262:  MOVWF  59
0263:  MOVLW  20
0264:  MOVWF  5A
0265:  MOVWF  5B
0266:  MOVWF  5C
0267:  MOVWF  5D
0268:  MOVWF  5E
0269:  MOVWF  5F
026A:  MOVWF  60
026B:  MOVWF  61
026C:  MOVWF  62
026D:  MOVWF  63
026E:  MOVWF  64
026F:  MOVWF  65
0270:  MOVWF  66
0271:  MOVWF  67
0272:  MOVWF  68
0273:  MOVWF  69
0274:  MOVWF  6A
0275:  CLRF   6B
....................     char An[] = {"                NGUYEN DINH AN-19151068                 "};
0276:  BSF    03.5
0277:  MOVWF  20
0278:  MOVWF  21
0279:  MOVWF  22
027A:  MOVWF  23
027B:  MOVWF  24
027C:  MOVWF  25
027D:  MOVWF  26
027E:  MOVWF  27
027F:  MOVWF  28
0280:  MOVWF  29
0281:  MOVWF  2A
0282:  MOVWF  2B
0283:  MOVWF  2C
0284:  MOVWF  2D
0285:  MOVWF  2E
0286:  MOVWF  2F
0287:  MOVLW  4E
0288:  MOVWF  30
0289:  MOVLW  47
028A:  MOVWF  31
028B:  MOVLW  55
028C:  MOVWF  32
028D:  MOVLW  59
028E:  MOVWF  33
028F:  MOVLW  45
0290:  MOVWF  34
0291:  MOVLW  4E
0292:  MOVWF  35
0293:  MOVLW  20
0294:  MOVWF  36
0295:  MOVLW  44
0296:  MOVWF  37
0297:  MOVLW  49
0298:  MOVWF  38
0299:  MOVLW  4E
029A:  MOVWF  39
029B:  MOVLW  48
029C:  MOVWF  3A
029D:  MOVLW  20
029E:  MOVWF  3B
029F:  MOVLW  41
02A0:  MOVWF  3C
02A1:  MOVLW  4E
02A2:  MOVWF  3D
02A3:  MOVLW  2D
02A4:  MOVWF  3E
02A5:  MOVLW  31
02A6:  MOVWF  3F
02A7:  MOVLW  39
02A8:  MOVWF  40
02A9:  MOVLW  31
02AA:  MOVWF  41
02AB:  MOVLW  35
02AC:  MOVWF  42
02AD:  MOVLW  31
02AE:  MOVWF  43
02AF:  MOVLW  30
02B0:  MOVWF  44
02B1:  MOVLW  36
02B2:  MOVWF  45
02B3:  MOVLW  38
02B4:  MOVWF  46
02B5:  MOVLW  20
02B6:  MOVWF  47
02B7:  MOVWF  48
02B8:  MOVWF  49
02B9:  MOVWF  4A
02BA:  MOVWF  4B
02BB:  MOVWF  4C
02BC:  MOVWF  4D
02BD:  MOVWF  4E
02BE:  MOVWF  4F
02BF:  MOVWF  50
02C0:  MOVWF  51
02C1:  MOVWF  52
02C2:  MOVWF  53
02C3:  MOVWF  54
02C4:  MOVWF  55
02C5:  MOVWF  56
02C6:  MOVWF  57
02C7:  CLRF   58
....................     signed char i,j;
....................     
....................     for (j = 1; j <= strlen(Tri) - 16; j++)
02C8:  MOVLW  01
02C9:  BCF    03.5
02CA:  MOVWF  6D
02CB:  BSF    03.5
02CC:  CLRF   5C
02CD:  MOVLW  34
02CE:  MOVWF  5B
*
02EC:  MOVLW  10
02ED:  SUBWF  78,W
02EE:  BCF    03.5
02EF:  BTFSC  6D.7
02F0:  GOTO   2F6
02F1:  SUBWF  6D,W
02F2:  BTFSC  03.2
02F3:  GOTO   2F6
02F4:  BTFSC  03.0
02F5:  GOTO   347
....................     {
....................         for(i = 1; i <= 16; i++)
02F6:  MOVLW  01
02F7:  MOVWF  6C
02F8:  BTFSC  6C.7
02F9:  GOTO   2FE
02FA:  MOVF   6C,W
02FB:  SUBLW  10
02FC:  BTFSS  03.0
02FD:  GOTO   326
....................         {
....................             lcd_gotoxy(i,1);
02FE:  MOVF   6C,W
02FF:  BSF    03.5
0300:  MOVWF  5F
0301:  MOVLW  01
0302:  MOVWF  60
0303:  BCF    03.5
0304:  CALL   15D
....................             printf(lcd_putc,"%c",Tri[i + j - 1]);
0305:  MOVF   6D,W
0306:  ADDWF  6C,W
0307:  ADDLW  FF
0308:  ADDLW  34
0309:  MOVWF  04
030A:  BCF    03.7
030B:  MOVF   00,W
030C:  MOVWF  6E
030D:  BSF    03.5
030E:  MOVWF  5E
030F:  BCF    03.5
0310:  CALL   182
....................             lcd_gotoxy(i,2);
0311:  MOVF   6C,W
0312:  BSF    03.5
0313:  MOVWF  5F
0314:  MOVLW  02
0315:  MOVWF  60
0316:  BCF    03.5
0317:  CALL   15D
....................             printf(lcd_putc,"%c",An[i + j - 1]);
0318:  MOVF   6D,W
0319:  ADDWF  6C,W
031A:  ADDLW  FF
031B:  ADDLW  A0
031C:  MOVWF  04
031D:  BCF    03.7
031E:  MOVF   00,W
031F:  MOVWF  6E
0320:  BSF    03.5
0321:  MOVWF  5E
0322:  BCF    03.5
0323:  CALL   182
0324:  INCF   6C,F
0325:  GOTO   2F8
....................         }
....................         delay_ms(300);
0326:  MOVLW  02
0327:  MOVWF  6E
0328:  MOVLW  96
0329:  BSF    03.5
032A:  MOVWF  5F
032B:  BCF    03.5
032C:  CALL   01F
032D:  DECFSZ 6E,F
032E:  GOTO   328
....................         if(!ok == 1){
032F:  BSF    31.2
0330:  MOVF   31,W
0331:  BSF    03.5
0332:  MOVWF  07
0333:  BCF    03.5
0334:  BTFSC  07.2
0335:  GOTO   345
....................             while(!ok == 1);
0336:  BSF    31.2
0337:  MOVF   31,W
0338:  BSF    03.5
0339:  MOVWF  07
033A:  BCF    03.5
033B:  BTFSS  07.2
033C:  GOTO   336
....................             lcd_putc("\f");
033D:  MOVLW  11
033E:  BSF    03.6
033F:  MOVWF  0D
0340:  MOVLW  00
0341:  MOVWF  0F
0342:  BCF    03.6
0343:  CALL   1B2
....................             break;
0344:  GOTO   347
....................          }
0345:  INCF   6D,F
0346:  GOTO   2CB
....................     }
....................     delay_ms(1000);
0347:  MOVLW  04
0348:  MOVWF  6E
0349:  MOVLW  FA
034A:  BSF    03.5
034B:  MOVWF  5F
034C:  BCF    03.5
034D:  CALL   01F
034E:  DECFSZ 6E,F
034F:  GOTO   349
0350:  BSF    0A.3
0351:  BCF    0A.4
0352:  GOTO   1CE (RETURN)
.................... }
.................... 
.................... void hienthi_gioihan(){
....................    lcd_gotoxy(1,2);
*
08DB:  MOVLW  01
08DC:  BSF    03.5
08DD:  MOVWF  5F
08DE:  MOVLW  02
08DF:  MOVWF  60
08E0:  BCF    0A.3
08E1:  BCF    03.5
08E2:  CALL   15D
08E3:  BSF    0A.3
....................    printf(lcd_putc, "Max: %d", gtmax);
08E4:  MOVLW  12
08E5:  BSF    03.6
08E6:  MOVWF  0D
08E7:  MOVLW  00
08E8:  MOVWF  0F
08E9:  BCF    03.0
08EA:  MOVLW  05
08EB:  BCF    03.6
08EC:  MOVWF  34
08ED:  CALL   000
08EE:  MOVF   2F,W
08EF:  MOVWF  34
08F0:  MOVLW  18
08F1:  MOVWF  35
08F2:  CALL   074
....................    lcd_gotoxy(9,2);
08F3:  MOVLW  09
08F4:  BSF    03.5
08F5:  MOVWF  5F
08F6:  MOVLW  02
08F7:  MOVWF  60
08F8:  BCF    0A.3
08F9:  BCF    03.5
08FA:  CALL   15D
08FB:  BSF    0A.3
....................    printf(lcd_putc,"Min: %d",gtmin);
08FC:  MOVLW  16
08FD:  BSF    03.6
08FE:  MOVWF  0D
08FF:  MOVLW  00
0900:  MOVWF  0F
0901:  BCF    03.0
0902:  MOVLW  05
0903:  BCF    03.6
0904:  MOVWF  34
0905:  CALL   000
0906:  MOVF   2E,W
0907:  MOVWF  34
0908:  MOVLW  18
0909:  MOVWF  35
090A:  CALL   074
....................    if(alarm == 1){
090B:  BTFSS  30.0
090C:  GOTO   120
....................       lcd_gotoxy(14,1);
090D:  MOVLW  0E
090E:  BSF    03.5
090F:  MOVWF  5F
0910:  MOVLW  01
0911:  MOVWF  60
0912:  BCF    0A.3
0913:  BCF    03.5
0914:  CALL   15D
0915:  BSF    0A.3
....................       lcd_putc("AL");
0916:  MOVLW  1A
0917:  BSF    03.6
0918:  MOVWF  0D
0919:  MOVLW  00
091A:  MOVWF  0F
091B:  BCF    0A.3
091C:  BCF    03.6
091D:  CALL   1B2
091E:  BSF    0A.3
....................    }
091F:  GOTO   134
....................    else if(alarm == 0){
0920:  BTFSC  30.0
0921:  GOTO   134
....................       lcd_gotoxy(14,1);
0922:  MOVLW  0E
0923:  BSF    03.5
0924:  MOVWF  5F
0925:  MOVLW  01
0926:  MOVWF  60
0927:  BCF    0A.3
0928:  BCF    03.5
0929:  CALL   15D
092A:  BSF    0A.3
....................       lcd_putc("  ");
092B:  MOVLW  1C
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   1B2
0933:  BSF    0A.3
....................    }
0934:  RETURN
.................... }
.................... void ktra_up(){
....................     if(!up == 1)
0935:  BSF    31.0
0936:  MOVF   31,W
0937:  BSF    03.5
0938:  MOVWF  07
0939:  BCF    03.5
093A:  BTFSC  07.0
093B:  GOTO   159
....................     {
....................         delay_ms(5);
093C:  MOVLW  05
093D:  BSF    03.5
093E:  MOVWF  5F
093F:  BCF    0A.3
0940:  BCF    03.5
0941:  CALL   01F
0942:  BSF    0A.3
....................         if(!up == 1)
0943:  BSF    31.0
0944:  MOVF   31,W
0945:  BSF    03.5
0946:  MOVWF  07
0947:  BCF    03.5
0948:  BTFSC  07.0
0949:  GOTO   159
....................         {
....................             while (!up == 1);
094A:  BSF    31.0
094B:  MOVF   31,W
094C:  BSF    03.5
094D:  MOVWF  07
094E:  BCF    03.5
094F:  BTFSS  07.0
0950:  GOTO   14A
....................             if(gtmax > 40)
0951:  MOVF   2F,W
0952:  SUBLW  28
0953:  BTFSC  03.0
0954:  GOTO   158
....................             {
....................                 gtmax = 20;
0955:  MOVLW  14
0956:  MOVWF  2F
....................             }
0957:  GOTO   159
....................             else{
....................                 gtmax++;
0958:  INCF   2F,F
....................             }
....................         }
....................     }
....................     hienthi_gioihan();
0959:  CALL   0DB
.................... }
.................... 
.................... void ktra_dw(){
....................     if(!dw == 1)
095A:  BSF    31.1
095B:  MOVF   31,W
095C:  BSF    03.5
095D:  MOVWF  07
095E:  BCF    03.5
095F:  BTFSC  07.1
0960:  GOTO   17E
....................     {
....................         delay_ms(5);
0961:  MOVLW  05
0962:  BSF    03.5
0963:  MOVWF  5F
0964:  BCF    0A.3
0965:  BCF    03.5
0966:  CALL   01F
0967:  BSF    0A.3
....................         if(!dw == 1)
0968:  BSF    31.1
0969:  MOVF   31,W
096A:  BSF    03.5
096B:  MOVWF  07
096C:  BCF    03.5
096D:  BTFSC  07.1
096E:  GOTO   17E
....................         {
....................             if(gtmin > 40)
096F:  MOVF   2E,W
0970:  SUBLW  28
0971:  BTFSC  03.0
0972:  GOTO   176
....................             {
....................                 gtmin = 20;
0973:  MOVLW  14
0974:  MOVWF  2E
....................             }
0975:  GOTO   177
....................             else{
....................                 gtmin++;
0976:  INCF   2E,F
....................             }
....................             while (!dw == 1);
0977:  BSF    31.1
0978:  MOVF   31,W
0979:  BSF    03.5
097A:  MOVWF  07
097B:  BCF    03.5
097C:  BTFSS  07.1
097D:  GOTO   177
....................         }
....................     }
....................     hienthi_gioihan();
097E:  CALL   0DB
.................... }
.................... 
.................... void ktra_ok()
.................... {
....................     if(!ok == 1)
097F:  BSF    31.2
0980:  MOVF   31,W
0981:  BSF    03.5
0982:  MOVWF  07
0983:  BCF    03.5
0984:  BTFSC  07.2
0985:  GOTO   1A0
....................     {
....................         delay_ms(5);
0986:  MOVLW  05
0987:  BSF    03.5
0988:  MOVWF  5F
0989:  BCF    0A.3
098A:  BCF    03.5
098B:  CALL   01F
098C:  BSF    0A.3
....................         if(!ok == 1)
098D:  BSF    31.2
098E:  MOVF   31,W
098F:  BSF    03.5
0990:  MOVWF  07
0991:  BCF    03.5
0992:  BTFSC  07.2
0993:  GOTO   1A0
....................         {
....................             if(alarm == 0)
0994:  BTFSC  30.0
0995:  GOTO   198
....................             {
....................                 alarm = 1;
0996:  BSF    30.0
....................             }
0997:  GOTO   199
....................             else{
....................                 alarm = 0;
0998:  BCF    30.0
....................             }
....................             while (!ok == 1);
0999:  BSF    31.2
099A:  MOVF   31,W
099B:  BSF    03.5
099C:  MOVWF  07
099D:  BCF    03.5
099E:  BTFSS  07.2
099F:  GOTO   199
....................         }
....................     }
....................     hienthi_gioihan();
09A0:  CALL   0DB
.................... }
.................... 
.................... void ktra_nutnhan(){
....................     ktra_up();
....................     ktra_dw();
....................     ktra_ok();
09A1:  BSF    0A.3
09A2:  BCF    0A.4
09A3:  GOTO   1EF (RETURN)
.................... }
.................... void start(){
....................     output_low(BUZ);
*
0033:  BCF    31.3
0034:  MOVF   31,W
0035:  BSF    03.5
0036:  MOVWF  07
0037:  BCF    03.5
0038:  BCF    07.3
....................     output_high(BUZ);
0039:  BCF    31.3
003A:  MOVF   31,W
003B:  BSF    03.5
003C:  MOVWF  07
003D:  BCF    03.5
003E:  BSF    07.3
....................     delay_ms(500);
003F:  MOVLW  02
0040:  MOVWF  34
0041:  MOVLW  FA
0042:  BSF    03.5
0043:  MOVWF  5F
0044:  BCF    03.5
0045:  CALL   01F
0046:  DECFSZ 34,F
0047:  GOTO   041
....................     output_low(BUZ);
0048:  BCF    31.3
0049:  MOVF   31,W
004A:  BSF    03.5
004B:  MOVWF  07
004C:  BCF    03.5
004D:  BCF    07.3
004E:  BSF    0A.3
004F:  BCF    0A.4
0050:  GOTO   1BF (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void main(){
*
09A4:  MOVF   03,W
09A5:  ANDLW  1F
09A6:  MOVWF  03
09A7:  CLRF   2B
09A8:  CLRF   2A
09A9:  MOVLW  1E
09AA:  MOVWF  2E
09AB:  MOVLW  20
09AC:  MOVWF  2F
09AD:  BSF    30.0
09AE:  MOVLW  FF
09AF:  MOVWF  31
09B0:  CLRF   33
09B1:  CLRF   32
09B2:  BSF    03.5
09B3:  BSF    1F.0
09B4:  BSF    1F.1
09B5:  BSF    1F.2
09B6:  BCF    1F.3
09B7:  MOVLW  07
09B8:  MOVWF  1C
09B9:  BCF    03.7
....................     start();
*
09BD:  BCF    0A.3
09BE:  GOTO   033
09BF:  BSF    0A.3
....................     lcd_init();
09C0:  BCF    0A.3
09C1:  GOTO   119
09C2:  BSF    0A.3
....................     lcd_putc("\f");
09C3:  MOVLW  1E
09C4:  BSF    03.6
09C5:  MOVWF  0D
09C6:  MOVLW  00
09C7:  MOVWF  0F
09C8:  BCF    0A.3
09C9:  BCF    03.6
09CA:  CALL   1B2
09CB:  BSF    0A.3
....................     hienthi_thongtin();
09CC:  BCF    0A.3
09CD:  GOTO   226
09CE:  BSF    0A.3
....................     setup_adc(adc_clock_div_2);
09CF:  BSF    03.5
09D0:  BCF    1F.6
09D1:  BCF    03.5
09D2:  BCF    1F.6
09D3:  BCF    1F.7
09D4:  BSF    03.5
09D5:  BSF    1F.7
09D6:  BCF    03.5
09D7:  BSF    1F.0
....................     setup_adc_ports(AN0);
09D8:  BSF    03.5
09D9:  BCF    1F.0
09DA:  BSF    1F.1
09DB:  BSF    1F.2
09DC:  BSF    1F.3
....................     while(true){
....................         doc_value_lm35();
09DD:  BCF    0A.3
09DE:  BCF    03.5
09DF:  GOTO   59A
09E0:  BSF    0A.3
....................         delay_ms(200);
09E1:  MOVLW  C8
09E2:  BSF    03.5
09E3:  MOVWF  5F
09E4:  BCF    0A.3
09E5:  BCF    03.5
09E6:  CALL   01F
09E7:  BSF    0A.3
....................         hienthi_lcd(1, 1);
09E8:  MOVLW  01
09E9:  MOVWF  34
09EA:  MOVWF  35
09EB:  BCF    0A.3
09EC:  GOTO   73D
09ED:  BSF    0A.3
....................         ktra_nutnhan();
09EE:  GOTO   135
....................         hienthi_gioihan();
09EF:  CALL   0DB
....................         delay_ms(200);
09F0:  MOVLW  C8
09F1:  BSF    03.5
09F2:  MOVWF  5F
09F3:  BCF    0A.3
09F4:  BCF    03.5
09F5:  CALL   01F
09F6:  BSF    0A.3
09F7:  BSF    03.5
09F8:  GOTO   1DD
.................... 
....................     }
.................... }
09F9:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
