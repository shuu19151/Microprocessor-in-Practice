CCS PCM C Compiler, Version 5.109, 43599               01-Dec-22 15:28

               Filename:   C:\Tri\HK 1 nam 4\TT micro\Project\Final\Code\DS18B20\test_DS18B20.lst

               ROM used:   2405 words (29%)
                           Largest free fragment is 2048
               RAM used:   21 (6%) at main() level
                           169 (46%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   134
0003:  NOP
.................... #include <test_DS18B20.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA D4,32
000D:  DATA 6D,38
000E:  DATA 3A,10
000F:  DATA 25,33
0010:  DATA 00,00
0011:  DATA 45,39
0012:  DATA F2,37
0013:  DATA 72,00
0014:  DATA 0C,00
0015:  DATA CD,30
0016:  DATA 78,1D
0017:  DATA A0,12
0018:  DATA 64,00
0019:  DATA CD,34
001A:  DATA 6E,1D
001B:  DATA A0,12
001C:  DATA 64,00
001D:  DATA 41,26
001E:  DATA 00,01
001F:  DATA 20,10
0020:  DATA 00,00
0021:  DATA 0C,00
*
01B5:  MOVF   0B,W
01B6:  BSF    03.5
01B7:  MOVWF  5B
01B8:  BCF    03.5
01B9:  BCF    0B.7
01BA:  BSF    03.5
01BB:  BSF    03.6
01BC:  BSF    0C.7
01BD:  BSF    0C.0
01BE:  NOP
01BF:  NOP
01C0:  BCF    03.6
01C1:  BTFSS  5B.7
01C2:  GOTO   1C6
01C3:  BCF    03.5
01C4:  BSF    0B.7
01C5:  BSF    03.5
01C6:  BCF    03.5
01C7:  BSF    03.6
01C8:  MOVF   0C,W
01C9:  ANDLW  7F
01CA:  BTFSC  03.2
01CB:  GOTO   227
01CC:  BSF    03.5
01CD:  BCF    03.6
01CE:  MOVWF  5B
01CF:  BCF    03.5
01D0:  BSF    03.6
01D1:  MOVF   0D,W
01D2:  BSF    03.5
01D3:  BCF    03.6
01D4:  MOVWF  5C
01D5:  BCF    03.5
01D6:  BSF    03.6
01D7:  MOVF   0F,W
01D8:  BSF    03.5
01D9:  BCF    03.6
01DA:  MOVWF  5D
01DB:  MOVF   5B,W
01DC:  MOVWF  5E
01DD:  BCF    03.5
01DE:  CALL   185
01DF:  BSF    03.5
01E0:  MOVF   5C,W
01E1:  BCF    03.5
01E2:  BSF    03.6
01E3:  MOVWF  0D
01E4:  BSF    03.5
01E5:  BCF    03.6
01E6:  MOVF   5D,W
01E7:  BCF    03.5
01E8:  BSF    03.6
01E9:  MOVWF  0F
01EA:  BCF    03.6
01EB:  MOVF   0B,W
01EC:  BSF    03.5
01ED:  MOVWF  5E
01EE:  BCF    03.5
01EF:  BCF    0B.7
01F0:  BSF    03.5
01F1:  BSF    03.6
01F2:  BSF    0C.7
01F3:  BSF    0C.0
01F4:  NOP
01F5:  NOP
01F6:  BCF    03.6
01F7:  BTFSS  5E.7
01F8:  GOTO   1FC
01F9:  BCF    03.5
01FA:  BSF    0B.7
01FB:  BSF    03.5
01FC:  BCF    03.5
01FD:  BSF    03.6
01FE:  RLF    0C,W
01FF:  RLF    0E,W
0200:  ANDLW  7F
0201:  BTFSC  03.2
0202:  GOTO   227
0203:  BSF    03.5
0204:  BCF    03.6
0205:  MOVWF  5B
0206:  BCF    03.5
0207:  BSF    03.6
0208:  MOVF   0D,W
0209:  BSF    03.5
020A:  BCF    03.6
020B:  MOVWF  5C
020C:  BCF    03.5
020D:  BSF    03.6
020E:  MOVF   0F,W
020F:  BSF    03.5
0210:  BCF    03.6
0211:  MOVWF  5D
0212:  MOVF   5B,W
0213:  MOVWF  5E
0214:  BCF    03.5
0215:  CALL   185
0216:  BSF    03.5
0217:  MOVF   5C,W
0218:  BCF    03.5
0219:  BSF    03.6
021A:  MOVWF  0D
021B:  BSF    03.5
021C:  BCF    03.6
021D:  MOVF   5D,W
021E:  BCF    03.5
021F:  BSF    03.6
0220:  MOVWF  0F
0221:  INCF   0D,F
0222:  BTFSC  03.2
0223:  INCF   0F,F
0224:  BCF    03.6
0225:  GOTO   1B5
0226:  BSF    03.6
0227:  BCF    03.6
0228:  RETURN
*
03EF:  MOVF   0B,W
03F0:  MOVWF  31
03F1:  BCF    0B.7
03F2:  BSF    03.5
03F3:  BSF    03.6
03F4:  BSF    0C.7
03F5:  BSF    0C.0
03F6:  NOP
03F7:  NOP
03F8:  BCF    03.5
03F9:  BCF    03.6
03FA:  BTFSC  31.7
03FB:  BSF    0B.7
03FC:  BTFSC  03.0
03FD:  GOTO   428
03FE:  BSF    03.6
03FF:  MOVF   0C,W
0400:  ANDLW  7F
0401:  BCF    03.6
0402:  MOVWF  31
0403:  BSF    03.6
0404:  MOVF   0D,W
0405:  BCF    03.6
0406:  MOVWF  32
0407:  BSF    03.6
0408:  MOVF   0F,W
0409:  BCF    03.6
040A:  MOVWF  33
040B:  MOVF   31,W
040C:  BSF    03.5
040D:  MOVWF  5E
040E:  BCF    03.5
040F:  CALL   185
0410:  MOVF   32,W
0411:  BSF    03.6
0412:  MOVWF  0D
0413:  BCF    03.6
0414:  MOVF   33,W
0415:  BSF    03.6
0416:  MOVWF  0F
0417:  BCF    03.6
0418:  MOVF   0B,W
0419:  MOVWF  34
041A:  BCF    0B.7
041B:  BSF    03.5
041C:  BSF    03.6
041D:  BSF    0C.7
041E:  BSF    0C.0
041F:  NOP
0420:  NOP
0421:  BCF    03.5
0422:  BCF    03.6
0423:  BTFSC  34.7
0424:  BSF    0B.7
0425:  DECFSZ 30,F
0426:  GOTO   428
0427:  GOTO   449
0428:  BSF    03.6
0429:  RLF    0C,W
042A:  RLF    0E,W
042B:  ANDLW  7F
042C:  BCF    03.6
042D:  MOVWF  31
042E:  BSF    03.6
042F:  MOVF   0D,W
0430:  BCF    03.6
0431:  MOVWF  32
0432:  BSF    03.6
0433:  MOVF   0F,W
0434:  BCF    03.6
0435:  MOVWF  33
0436:  MOVF   31,W
0437:  BSF    03.5
0438:  MOVWF  5E
0439:  BCF    03.5
043A:  CALL   185
043B:  MOVF   32,W
043C:  BSF    03.6
043D:  MOVWF  0D
043E:  BCF    03.6
043F:  MOVF   33,W
0440:  BSF    03.6
0441:  MOVWF  0F
0442:  INCF   0D,F
0443:  BTFSC  03.2
0444:  INCF   0F,F
0445:  BCF    03.0
0446:  BCF    03.6
0447:  DECFSZ 30,F
0448:  GOTO   3EF
0449:  RETURN
044A:  BTFSC  03.1
044B:  GOTO   44F
044C:  MOVLW  45
044D:  MOVWF  04
044E:  BCF    03.7
044F:  CLRF   77
0450:  CLRF   78
0451:  CLRF   79
0452:  CLRF   7A
0453:  CLRF   45
0454:  CLRF   46
0455:  CLRF   47
0456:  CLRF   48
0457:  MOVF   44,W
0458:  IORWF  43,W
0459:  IORWF  42,W
045A:  IORWF  41,W
045B:  BTFSC  03.2
045C:  GOTO   48D
045D:  MOVLW  20
045E:  MOVWF  49
045F:  BCF    03.0
0460:  RLF    3D,F
0461:  RLF    3E,F
0462:  RLF    3F,F
0463:  RLF    40,F
0464:  RLF    45,F
0465:  RLF    46,F
0466:  RLF    47,F
0467:  RLF    48,F
0468:  MOVF   44,W
0469:  SUBWF  48,W
046A:  BTFSS  03.2
046B:  GOTO   476
046C:  MOVF   43,W
046D:  SUBWF  47,W
046E:  BTFSS  03.2
046F:  GOTO   476
0470:  MOVF   42,W
0471:  SUBWF  46,W
0472:  BTFSS  03.2
0473:  GOTO   476
0474:  MOVF   41,W
0475:  SUBWF  45,W
0476:  BTFSS  03.0
0477:  GOTO   487
0478:  MOVF   41,W
0479:  SUBWF  45,F
047A:  MOVF   42,W
047B:  BTFSS  03.0
047C:  INCFSZ 42,W
047D:  SUBWF  46,F
047E:  MOVF   43,W
047F:  BTFSS  03.0
0480:  INCFSZ 43,W
0481:  SUBWF  47,F
0482:  MOVF   44,W
0483:  BTFSS  03.0
0484:  INCFSZ 44,W
0485:  SUBWF  48,F
0486:  BSF    03.0
0487:  RLF    77,F
0488:  RLF    78,F
0489:  RLF    79,F
048A:  RLF    7A,F
048B:  DECFSZ 49,F
048C:  GOTO   45F
048D:  MOVF   45,W
048E:  MOVWF  00
048F:  INCF   04,F
0490:  MOVF   46,W
0491:  MOVWF  00
0492:  INCF   04,F
0493:  MOVF   47,W
0494:  MOVWF  00
0495:  INCF   04,F
0496:  MOVF   48,W
0497:  MOVWF  00
0498:  RETURN
0499:  MOVF   04,W
049A:  MOVWF  35
049B:  MOVF   34,W
049C:  MOVWF  37
049D:  BTFSC  03.2
049E:  GOTO   52B
049F:  MOVF   33,W
04A0:  MOVWF  40
04A1:  MOVF   32,W
04A2:  MOVWF  3F
04A3:  MOVF   31,W
04A4:  MOVWF  3E
04A5:  MOVF   30,W
04A6:  MOVWF  3D
04A7:  CLRF   44
04A8:  CLRF   43
04A9:  MOVLW  20
04AA:  MOVWF  42
04AB:  MOVLW  82
04AC:  MOVWF  41
04AD:  MOVF   3D,W
04AE:  BTFSC  03.2
04AF:  GOTO   51D
04B0:  MOVWF  45
04B1:  MOVF   41,W
04B2:  BTFSC  03.2
04B3:  GOTO   51D
04B4:  ADDWF  45,F
04B5:  BTFSC  03.0
04B6:  GOTO   4BE
04B7:  MOVLW  7F
04B8:  SUBWF  45,F
04B9:  BTFSS  03.0
04BA:  GOTO   51D
04BB:  BTFSC  03.2
04BC:  GOTO   51D
04BD:  GOTO   4C2
04BE:  MOVLW  81
04BF:  ADDWF  45,F
04C0:  BTFSC  03.0
04C1:  GOTO   51D
04C2:  MOVF   45,W
04C3:  MOVWF  77
04C4:  CLRF   78
04C5:  CLRF   79
04C6:  CLRF   7A
04C7:  MOVF   3E,W
04C8:  MOVWF  49
04C9:  BSF    49.7
04CA:  MOVF   3F,W
04CB:  MOVWF  48
04CC:  MOVF   40,W
04CD:  MOVWF  47
04CE:  MOVLW  18
04CF:  MOVWF  45
04D0:  CLRF   46
04D1:  BTFSS  47.0
04D2:  GOTO   4EB
04D3:  MOVF   44,W
04D4:  ADDWF  7A,F
04D5:  BTFSS  03.0
04D6:  GOTO   4DD
04D7:  INCF   79,F
04D8:  BTFSS  03.2
04D9:  GOTO   4DD
04DA:  INCF   78,F
04DB:  BTFSC  03.2
04DC:  BSF    46.7
04DD:  MOVF   43,W
04DE:  ADDWF  79,F
04DF:  BTFSS  03.0
04E0:  GOTO   4E4
04E1:  INCF   78,F
04E2:  BTFSC  03.2
04E3:  BSF    46.7
04E4:  MOVF   42,W
04E5:  MOVWF  3F
04E6:  BSF    3F.7
04E7:  MOVF   3F,W
04E8:  ADDWF  78,F
04E9:  BTFSC  03.0
04EA:  BSF    46.7
04EB:  RLF    46,F
04EC:  RRF    78,F
04ED:  RRF    79,F
04EE:  RRF    7A,F
04EF:  RRF    49,F
04F0:  RRF    48,F
04F1:  RRF    47,F
04F2:  BCF    03.0
04F3:  DECFSZ 45,F
04F4:  GOTO   4D0
04F5:  MOVLW  01
04F6:  ADDWF  77,F
04F7:  BTFSC  03.0
04F8:  GOTO   51D
04F9:  BTFSC  78.7
04FA:  GOTO   502
04FB:  RLF    49,F
04FC:  RLF    7A,F
04FD:  RLF    79,F
04FE:  RLF    78,F
04FF:  DECF   77,F
0500:  BTFSC  03.2
0501:  GOTO   51D
0502:  BTFSS  49.7
0503:  GOTO   513
0504:  INCF   7A,F
0505:  BTFSS  03.2
0506:  GOTO   513
0507:  INCF   79,F
0508:  BTFSS  03.2
0509:  GOTO   513
050A:  INCF   78,F
050B:  BTFSS  03.2
050C:  GOTO   513
050D:  RRF    78,F
050E:  RRF    79,F
050F:  RRF    7A,F
0510:  INCF   77,F
0511:  BTFSC  03.2
0512:  GOTO   51D
0513:  MOVF   3E,W
0514:  MOVWF  46
0515:  MOVF   42,W
0516:  XORWF  46,F
0517:  BTFSS  46.7
0518:  GOTO   51B
0519:  BSF    78.7
051A:  GOTO   521
051B:  BCF    78.7
051C:  GOTO   521
051D:  CLRF   77
051E:  CLRF   78
051F:  CLRF   79
0520:  CLRF   7A
0521:  MOVF   7A,W
0522:  MOVWF  33
0523:  MOVF   79,W
0524:  MOVWF  32
0525:  MOVF   78,W
0526:  MOVWF  31
0527:  MOVF   77,W
0528:  MOVWF  30
0529:  DECFSZ 37,F
052A:  GOTO   49F
052B:  MOVF   33,W
052C:  MOVWF  40
052D:  MOVF   32,W
052E:  MOVWF  3F
052F:  MOVF   31,W
0530:  MOVWF  3E
0531:  MOVF   30,W
0532:  MOVWF  3D
0533:  MOVF   3D,W
0534:  SUBLW  B6
0535:  MOVWF  3D
0536:  CLRF   7A
0537:  MOVF   3E,W
0538:  MOVWF  41
0539:  BSF    3E.7
053A:  BCF    03.0
053B:  RRF    3E,F
053C:  RRF    3F,F
053D:  RRF    40,F
053E:  RRF    7A,F
053F:  RRF    79,F
0540:  RRF    78,F
0541:  RRF    77,F
0542:  DECFSZ 3D,F
0543:  GOTO   53A
0544:  BTFSS  41.7
0545:  GOTO   551
0546:  COMF   77,F
0547:  COMF   78,F
0548:  COMF   79,F
0549:  COMF   7A,F
054A:  INCF   77,F
054B:  BTFSC  03.2
054C:  INCF   78,F
054D:  BTFSC  03.2
054E:  INCF   79,F
054F:  BTFSC  03.2
0550:  INCF   7A,F
0551:  MOVF   7A,W
0552:  MOVWF  33
0553:  MOVF   79,W
0554:  MOVWF  32
0555:  MOVF   78,W
0556:  MOVWF  31
0557:  MOVF   77,W
0558:  MOVWF  30
0559:  BTFSS  33.7
055A:  GOTO   568
055B:  DECF   35,F
055C:  BSF    35.5
055D:  COMF   30,F
055E:  COMF   31,F
055F:  COMF   32,F
0560:  COMF   33,F
0561:  INCF   30,F
0562:  BTFSC  03.2
0563:  INCF   31,F
0564:  BTFSC  03.2
0565:  INCF   32,F
0566:  BTFSC  03.2
0567:  INCF   33,F
0568:  MOVLW  3B
0569:  MOVWF  3C
056A:  MOVLW  9A
056B:  MOVWF  3B
056C:  MOVLW  CA
056D:  MOVWF  3A
056E:  CLRF   39
056F:  MOVLW  0A
0570:  MOVWF  37
0571:  MOVF   34,W
0572:  BTFSC  03.2
0573:  INCF   35,F
0574:  BSF    03.1
0575:  MOVLW  30
0576:  MOVWF  04
0577:  BCF    03.7
0578:  MOVF   33,W
0579:  MOVWF  40
057A:  MOVF   32,W
057B:  MOVWF  3F
057C:  MOVF   31,W
057D:  MOVWF  3E
057E:  MOVF   30,W
057F:  MOVWF  3D
0580:  MOVF   3C,W
0581:  MOVWF  44
0582:  MOVF   3B,W
0583:  MOVWF  43
0584:  MOVF   3A,W
0585:  MOVWF  42
0586:  MOVF   39,W
0587:  MOVWF  41
0588:  CALL   44A
0589:  MOVF   78,W
058A:  MOVF   77,F
058B:  BTFSS  03.2
058C:  GOTO   5A0
058D:  INCF   34,W
058E:  SUBWF  37,W
058F:  BTFSC  03.2
0590:  GOTO   5A0
0591:  MOVF   35,W
0592:  BTFSC  03.2
0593:  GOTO   5A2
0594:  ANDLW  0F
0595:  SUBWF  37,W
0596:  BTFSC  03.2
0597:  GOTO   59A
0598:  BTFSC  03.0
0599:  GOTO   5DA
059A:  BTFSC  35.7
059B:  GOTO   5DA
059C:  BTFSC  35.6
059D:  GOTO   5A2
059E:  MOVLW  20
059F:  GOTO   5D4
05A0:  MOVLW  20
05A1:  ANDWF  35,F
05A2:  BTFSS  35.5
05A3:  GOTO   5B2
05A4:  BCF    35.5
05A5:  MOVF   34,W
05A6:  BTFSS  03.2
05A7:  DECF   35,F
05A8:  MOVF   77,W
05A9:  MOVWF  35
05AA:  MOVLW  2D
05AB:  BSF    03.5
05AC:  MOVWF  5E
05AD:  BCF    03.5
05AE:  CALL   185
05AF:  MOVF   35,W
05B0:  MOVWF  77
05B1:  CLRF   35
05B2:  MOVF   34,W
05B3:  SUBWF  37,W
05B4:  BTFSS  03.2
05B5:  GOTO   5C2
05B6:  MOVF   77,W
05B7:  MOVWF  35
05B8:  MOVLW  2E
05B9:  BSF    03.5
05BA:  MOVWF  5E
05BB:  BCF    03.5
05BC:  CALL   185
05BD:  MOVF   35,W
05BE:  MOVWF  77
05BF:  MOVLW  20
05C0:  ANDWF  35,F
05C1:  MOVLW  00
05C2:  MOVLW  30
05C3:  BTFSS  35.5
05C4:  GOTO   5D4
05C5:  BCF    35.5
05C6:  MOVF   34,W
05C7:  BTFSS  03.2
05C8:  DECF   35,F
05C9:  MOVF   77,W
05CA:  MOVWF  35
05CB:  MOVLW  2D
05CC:  BSF    03.5
05CD:  MOVWF  5E
05CE:  BCF    03.5
05CF:  CALL   185
05D0:  MOVF   35,W
05D1:  MOVWF  77
05D2:  CLRF   35
05D3:  MOVLW  30
05D4:  ADDWF  77,F
05D5:  MOVF   77,W
05D6:  BSF    03.5
05D7:  MOVWF  5E
05D8:  BCF    03.5
05D9:  CALL   185
05DA:  BCF    03.1
05DB:  MOVF   3C,W
05DC:  MOVWF  40
05DD:  MOVF   3B,W
05DE:  MOVWF  3F
05DF:  MOVF   3A,W
05E0:  MOVWF  3E
05E1:  MOVF   39,W
05E2:  MOVWF  3D
05E3:  CLRF   44
05E4:  CLRF   43
05E5:  CLRF   42
05E6:  MOVLW  0A
05E7:  MOVWF  41
05E8:  CALL   44A
05E9:  MOVF   7A,W
05EA:  MOVWF  3C
05EB:  MOVF   79,W
05EC:  MOVWF  3B
05ED:  MOVF   78,W
05EE:  MOVWF  3A
05EF:  MOVF   77,W
05F0:  MOVWF  39
05F1:  DECFSZ 37,F
05F2:  GOTO   574
05F3:  BCF    0A.3
05F4:  BCF    0A.4
05F5:  GOTO   7A7 (RETURN)
*
0655:  MOVLW  8E
0656:  MOVWF  77
0657:  MOVF   31,W
0658:  MOVWF  78
0659:  MOVF   30,W
065A:  MOVWF  79
065B:  CLRF   7A
065C:  BTFSS  31.7
065D:  GOTO   663
065E:  COMF   78,F
065F:  COMF   79,F
0660:  INCF   79,F
0661:  BTFSC  03.2
0662:  INCF   78,F
0663:  MOVF   78,F
0664:  BTFSS  03.2
0665:  GOTO   670
0666:  MOVF   79,W
0667:  MOVWF  78
0668:  CLRF   79
0669:  MOVLW  08
066A:  SUBWF  77,F
066B:  MOVF   78,F
066C:  BTFSS  03.2
066D:  GOTO   670
066E:  CLRF   77
066F:  GOTO   679
0670:  BCF    03.0
0671:  BTFSC  78.7
0672:  GOTO   677
0673:  RLF    79,F
0674:  RLF    78,F
0675:  DECF   77,F
0676:  GOTO   670
0677:  BTFSS  31.7
0678:  BCF    78.7
*
068E:  MOVF   34,W
068F:  BTFSC  03.2
0690:  GOTO   753
0691:  MOVWF  40
0692:  MOVF   38,W
0693:  BTFSC  03.2
0694:  GOTO   753
0695:  SUBWF  40,F
0696:  BTFSS  03.0
0697:  GOTO   69D
0698:  MOVLW  7F
0699:  ADDWF  40,F
069A:  BTFSC  03.0
069B:  GOTO   753
069C:  GOTO   6A3
069D:  MOVLW  81
069E:  SUBWF  40,F
069F:  BTFSS  03.0
06A0:  GOTO   753
06A1:  BTFSC  03.2
06A2:  GOTO   753
06A3:  MOVF   40,W
06A4:  MOVWF  77
06A5:  CLRF   78
06A6:  CLRF   79
06A7:  CLRF   7A
06A8:  CLRF   3F
06A9:  MOVF   35,W
06AA:  MOVWF  3E
06AB:  BSF    3E.7
06AC:  MOVF   36,W
06AD:  MOVWF  3D
06AE:  MOVF   37,W
06AF:  MOVWF  3C
06B0:  MOVLW  19
06B1:  MOVWF  40
06B2:  MOVF   3B,W
06B3:  SUBWF  3C,F
06B4:  BTFSC  03.0
06B5:  GOTO   6C6
06B6:  MOVLW  01
06B7:  SUBWF  3D,F
06B8:  BTFSC  03.0
06B9:  GOTO   6C6
06BA:  SUBWF  3E,F
06BB:  BTFSC  03.0
06BC:  GOTO   6C6
06BD:  SUBWF  3F,F
06BE:  BTFSC  03.0
06BF:  GOTO   6C6
06C0:  INCF   3F,F
06C1:  INCF   3E,F
06C2:  INCF   3D,F
06C3:  MOVF   3B,W
06C4:  ADDWF  3C,F
06C5:  GOTO   6F8
06C6:  MOVF   3A,W
06C7:  SUBWF  3D,F
06C8:  BTFSC  03.0
06C9:  GOTO   6E1
06CA:  MOVLW  01
06CB:  SUBWF  3E,F
06CC:  BTFSC  03.0
06CD:  GOTO   6E1
06CE:  SUBWF  3F,F
06CF:  BTFSC  03.0
06D0:  GOTO   6E1
06D1:  INCF   3F,F
06D2:  INCF   3E,F
06D3:  MOVF   3A,W
06D4:  ADDWF  3D,F
06D5:  MOVF   3B,W
06D6:  ADDWF  3C,F
06D7:  BTFSS  03.0
06D8:  GOTO   6F8
06D9:  INCF   3D,F
06DA:  BTFSS  03.2
06DB:  GOTO   6F8
06DC:  INCF   3E,F
06DD:  BTFSS  03.2
06DE:  GOTO   6F8
06DF:  INCF   3F,F
06E0:  GOTO   6F8
06E1:  MOVF   39,W
06E2:  IORLW  80
06E3:  SUBWF  3E,F
06E4:  BTFSC  03.0
06E5:  GOTO   6F7
06E6:  MOVLW  01
06E7:  SUBWF  3F,F
06E8:  BTFSC  03.0
06E9:  GOTO   6F7
06EA:  INCF   3F,F
06EB:  MOVF   39,W
06EC:  IORLW  80
06ED:  ADDWF  3E,F
06EE:  MOVF   3A,W
06EF:  ADDWF  3D,F
06F0:  BTFSS  03.0
06F1:  GOTO   6D5
06F2:  INCF   3E,F
06F3:  BTFSS  03.2
06F4:  GOTO   6D5
06F5:  INCF   3F,F
06F6:  GOTO   6D5
06F7:  BSF    7A.0
06F8:  DECFSZ 40,F
06F9:  GOTO   6FB
06FA:  GOTO   706
06FB:  BCF    03.0
06FC:  RLF    3C,F
06FD:  RLF    3D,F
06FE:  RLF    3E,F
06FF:  RLF    3F,F
0700:  BCF    03.0
0701:  RLF    7A,F
0702:  RLF    79,F
0703:  RLF    78,F
0704:  RLF    41,F
0705:  GOTO   6B2
0706:  BTFSS  41.0
0707:  GOTO   70E
0708:  BCF    03.0
0709:  RRF    78,F
070A:  RRF    79,F
070B:  RRF    7A,F
070C:  RRF    41,F
070D:  GOTO   711
070E:  DECF   77,F
070F:  BTFSC  03.2
0710:  GOTO   753
0711:  BTFSC  41.7
0712:  GOTO   73A
0713:  BCF    03.0
0714:  RLF    3C,F
0715:  RLF    3D,F
0716:  RLF    3E,F
0717:  RLF    3F,F
0718:  MOVF   3B,W
0719:  SUBWF  3C,F
071A:  BTFSC  03.0
071B:  GOTO   726
071C:  MOVLW  01
071D:  SUBWF  3D,F
071E:  BTFSC  03.0
071F:  GOTO   726
0720:  SUBWF  3E,F
0721:  BTFSC  03.0
0722:  GOTO   726
0723:  SUBWF  3F,F
0724:  BTFSS  03.0
0725:  GOTO   749
0726:  MOVF   3A,W
0727:  SUBWF  3D,F
0728:  BTFSC  03.0
0729:  GOTO   731
072A:  MOVLW  01
072B:  SUBWF  3E,F
072C:  BTFSC  03.0
072D:  GOTO   731
072E:  SUBWF  3F,F
072F:  BTFSS  03.0
0730:  GOTO   749
0731:  MOVF   39,W
0732:  IORLW  80
0733:  SUBWF  3E,F
0734:  BTFSC  03.0
0735:  GOTO   73A
0736:  MOVLW  01
0737:  SUBWF  3F,F
0738:  BTFSS  03.0
0739:  GOTO   749
073A:  INCF   7A,F
073B:  BTFSS  03.2
073C:  GOTO   749
073D:  INCF   79,F
073E:  BTFSS  03.2
073F:  GOTO   749
0740:  INCF   78,F
0741:  BTFSS  03.2
0742:  GOTO   749
0743:  INCF   77,F
0744:  BTFSC  03.2
0745:  GOTO   753
0746:  RRF    78,F
0747:  RRF    79,F
0748:  RRF    7A,F
0749:  MOVF   35,W
074A:  MOVWF  40
074B:  MOVF   39,W
074C:  XORWF  40,F
074D:  BTFSS  40.7
074E:  GOTO   751
074F:  BSF    78.7
0750:  GOTO   757
0751:  BCF    78.7
0752:  GOTO   757
0753:  CLRF   77
0754:  CLRF   78
0755:  CLRF   79
0756:  CLRF   7A
*
0767:  MOVLW  8E
0768:  MOVWF  77
0769:  MOVF   30,W
076A:  SUBWF  77,F
076B:  MOVF   31,W
076C:  MOVWF  79
076D:  MOVF   32,W
076E:  MOVWF  78
076F:  BSF    79.7
0770:  MOVF   77,F
0771:  BTFSC  03.2
0772:  GOTO   77E
0773:  BCF    03.0
0774:  MOVF   79,F
0775:  BTFSS  03.2
0776:  GOTO   77A
0777:  MOVF   78,F
0778:  BTFSC  03.2
0779:  GOTO   77E
077A:  RRF    79,F
077B:  RRF    78,F
077C:  DECFSZ 77,F
077D:  GOTO   773
077E:  BTFSS  31.7
077F:  GOTO   785
0780:  COMF   78,F
0781:  COMF   79,F
0782:  INCF   78,F
0783:  BTFSC  03.2
0784:  INCF   79,F
*
07E6:  MOVF   37,W
07E7:  CLRF   78
07E8:  SUBWF  36,W
07E9:  BTFSC  03.0
07EA:  GOTO   7EE
07EB:  MOVF   36,W
07EC:  MOVWF  77
07ED:  GOTO   7FA
07EE:  CLRF   77
07EF:  MOVLW  08
07F0:  MOVWF  38
07F1:  RLF    36,F
07F2:  RLF    77,F
07F3:  MOVF   37,W
07F4:  SUBWF  77,W
07F5:  BTFSC  03.0
07F6:  MOVWF  77
07F7:  RLF    78,F
07F8:  DECFSZ 38,F
07F9:  GOTO   7F1
07FA:  RETURN
*
0800:  MOVLW  20
0801:  BTFSS  31.4
0802:  MOVLW  30
0803:  MOVWF  32
0804:  MOVF   30,W
0805:  MOVWF  77
0806:  BTFSS  30.7
0807:  GOTO   010
0808:  COMF   77,F
0809:  INCF   77,F
080A:  MOVF   77,W
080B:  MOVWF  30
080C:  MOVLW  2D
080D:  MOVWF  32
080E:  BSF    31.7
080F:  BSF    31.0
0810:  MOVF   30,W
0811:  MOVWF  36
0812:  MOVLW  64
0813:  MOVWF  37
0814:  BCF    0A.3
0815:  CALL   7E6
0816:  BSF    0A.3
0817:  MOVF   77,W
0818:  MOVWF  30
0819:  MOVLW  30
081A:  ADDWF  78,W
081B:  MOVWF  33
081C:  MOVF   30,W
081D:  MOVWF  36
081E:  MOVLW  0A
081F:  MOVWF  37
0820:  BCF    0A.3
0821:  CALL   7E6
0822:  BSF    0A.3
0823:  MOVLW  30
0824:  ADDWF  77,W
0825:  MOVWF  35
0826:  MOVLW  30
0827:  ADDWF  78,W
0828:  MOVWF  34
0829:  MOVF   32,W
082A:  MOVWF  77
082B:  MOVLW  30
082C:  SUBWF  33,W
082D:  BTFSC  03.2
082E:  GOTO   033
082F:  BSF    31.1
0830:  BTFSC  31.7
0831:  BSF    31.2
0832:  GOTO   047
0833:  MOVF   32,W
0834:  MOVWF  33
0835:  MOVLW  20
0836:  MOVWF  32
0837:  MOVLW  30
0838:  SUBWF  34,W
0839:  BTFSC  03.2
083A:  GOTO   03F
083B:  BSF    31.0
083C:  BTFSC  31.7
083D:  BSF    31.1
083E:  GOTO   047
083F:  BTFSS  03.2
0840:  BSF    31.0
0841:  BTFSS  03.2
0842:  GOTO   047
0843:  MOVF   33,W
0844:  MOVWF  34
0845:  MOVLW  20
0846:  MOVWF  33
0847:  BTFSC  31.2
0848:  GOTO   04E
0849:  BTFSC  31.1
084A:  GOTO   055
084B:  BTFSC  31.0
084C:  GOTO   05C
084D:  GOTO   063
084E:  MOVF   32,W
084F:  BSF    03.5
0850:  MOVWF  5E
0851:  BCF    0A.3
0852:  BCF    03.5
0853:  CALL   185
0854:  BSF    0A.3
0855:  MOVF   33,W
0856:  BSF    03.5
0857:  MOVWF  5E
0858:  BCF    0A.3
0859:  BCF    03.5
085A:  CALL   185
085B:  BSF    0A.3
085C:  MOVF   34,W
085D:  BSF    03.5
085E:  MOVWF  5E
085F:  BCF    0A.3
0860:  BCF    03.5
0861:  CALL   185
0862:  BSF    0A.3
0863:  MOVF   35,W
0864:  BSF    03.5
0865:  MOVWF  5E
0866:  BCF    0A.3
0867:  BCF    03.5
0868:  CALL   185
0869:  BSF    0A.3
086A:  RETURN
.................... 
.................... #list
.................... 
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #use delay(crystal=20000000)
.................... 
.................... #include <lcd.h>
.................... #define _lcd_h_
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #use delay(clock=20000000)
*
0022:  MOVLW  DF
0023:  MOVWF  04
0024:  BCF    03.7
0025:  MOVF   00,W
0026:  BTFSC  03.2
0027:  GOTO   035
0028:  MOVLW  06
0029:  MOVWF  78
002A:  CLRF   77
002B:  DECFSZ 77,F
002C:  GOTO   02B
002D:  DECFSZ 78,F
002E:  GOTO   02A
002F:  MOVLW  7B
0030:  MOVWF  77
0031:  DECFSZ 77,F
0032:  GOTO   031
0033:  DECFSZ 00,F
0034:  GOTO   028
0035:  RETURN
*
0356:  MOVLW  03
0357:  SUBWF  33,F
0358:  BTFSS  03.0
0359:  GOTO   364
035A:  MOVLW  33
035B:  MOVWF  04
035C:  BCF    03.7
035D:  MOVF   00,W
035E:  BTFSC  03.2
035F:  GOTO   364
0360:  GOTO   362
0361:  GOTO   362
0362:  DECFSZ 00,F
0363:  GOTO   361
0364:  RETURN
.................... void lcd_init(void);             // Ham dung de khoi dong C.LCD.
.................... byte lcd_read_byte(void);         // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... byte lcd_read_nibble(void);         // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
.................... void lcd_send_byte(byte address, byte n);   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... void lcd_send_nibble(byte n);      // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... void lcd_gotoxy(byte x, byte y);   // Ham thiet lap vi tri ghi tren C.LCD.
.................... char lcd_getc(byte x, byte y);      // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... void lcd_putc(char c);            // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... // Khai bao bien.
.................... // Dinh nghia cac thong so.
.................... #define LCD_RS_PIN         PIN_B4   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN         PIN_B3
.................... #define LCD_ENABLE_PIN     PIN_B2
.................... #define LCD_DATA4          PIN_D7
.................... #define LCD_DATA5          PIN_D6
.................... #define LCD_DATA6          PIN_D5
.................... #define LCD_DATA7          PIN_D4
.................... 
.................... //!#define LCD_RS_PIN         PIN_C0   // Cac ket noi C.LCD voi vi dieu khien.
.................... //!#define LCD_RW_PIN         PIN_C1
.................... //!#define LCD_ENABLE_PIN     PIN_C2
.................... //!#define LCD_DATA4          PIN_C3
.................... //!#define LCD_DATA5          PIN_C4
.................... //!#define LCD_DATA6          PIN_C5
.................... //!#define LCD_DATA7          PIN_C6
.................... 
.................... /*
.................... #define LCD_RS_PIN         PIN_D1   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN      PIN_D2
.................... #define LCD_ENABLE_PIN  PIN_D3
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7  
.................... */
.................... #define lcd_output_enable(x)   output_bit(LCD_ENABLE_PIN, x)   // Lenh dieu khien chan LCD_ENABLE_PIN.
.................... #define lcd_enable_tris()   output_drive(LCD_ENABLE_PIN)
.................... 
.................... #define lcd_output_rs(x)   output_bit(LCD_RS_PIN, x)   // Lenh dieu khien chan LCD_RS_PIN.
.................... #define lcd_rs_tris()      output_drive(LCD_RS_PIN)
.................... 
.................... #define lcd_output_rw(x)   output_bit(LCD_RW_PIN, x)   // Lenh dieu khien chan LCD_RW_PIN
.................... #define lcd_rw_tris()      output_drive(LCD_RW_PIN)
.................... 
.................... #define lcd_line_one   0x00    // Dia chi RAM C.LCD cho hang thu 1.
.................... #define lcd_line_two   0x40    // Dia chi RAM C.LCD cho hang thu 2.
.................... #define lcd_line_three   0x14
.................... #define lcd_line_four   0x54
.................... #define LCD_TYPE 0x02           // Thong tin cau hinh C.LCD: 0x00=5x7, 0x01=5x10, 0x02=2 lines
.................... 
.................... // Dinh nghia cac hang so.
.................... byte const LCD_INIT_STRING[4] = {0x28 | (LCD_TYPE << 2), 0x0C, 0x01, 0x06};
....................         // Cac byte nay can thiet de gui toi C.LCD, dung de khoi dong cau hinh hoat dong cho C.LCD.
....................       // Byte 1: 0x20 | (LCD_TYPE << 2) - So bit du lieu giao tiep (DL), so dong hien thi (N), kieu ky tu (F).
....................       //         0 0 1 DL N F x x (DL: Data Length, N: Number Line, F: Font).
....................          // Truong hop 1: 0x20 - 4 bit / 1 dong / 5 x 7.
....................          // Truong hop 2: 0x24 - 4 bit / 1 dong / 5 x 10.
....................          // Truong hop 3: 0x28 - 4 bit / 2 dong / 5 x 7.
....................       // Byte 2: 0x0C - Dieu khien hien thi (Bat hien thi, tat con tro, tat nhap nhay con tro).
....................       //         0 0 0 0 1 D C B (D: Display, C: Cursor, B: Blink).
....................       // Byte 3: 0x01 - Xoa hien thi va tra con tro ve dau dong.
....................       // Byte 4: 0x06 - Dat che do dau vao (Che do tang dia chi, tat dich chuyen hien thi).
....................       //         0 0 0 0 0 1 I/D S (I/D: Increment/Decrement, S: Shift).
....................       // Byte 5: .... - Doi con tro / hien thi.
....................       //         0 0 0 1 S/C R/L x x (S/C: Screen/Cursor, R/L: Right/Left).
.................... 
.................... // ***************************************************
.................... void lcd_init(void)    // Ham dung de khoi dong C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte i;
.................... // Dinh nghia ham.
.................... output_drive(LCD_DATA4);   // Thiet lap chan port (Data) o che do ngo ra.
*
011C:  BSF    03.5
011D:  BCF    08.7
.................... output_drive(LCD_DATA5);
011E:  BCF    08.6
.................... output_drive(LCD_DATA6);
011F:  BCF    08.5
.................... output_drive(LCD_DATA7);
0120:  BCF    08.4
.................... 
.................... lcd_enable_tris();         // Thiet lap chan port (Control: EN, RS, RW) o che do ngo ra.
0121:  BCF    06.2
.................... lcd_rs_tris();
0122:  BCF    06.4
.................... lcd_rw_tris();
0123:  BCF    06.3
.................... 
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
0124:  BCF    03.5
0125:  BCF    06.4
0126:  BSF    03.5
0127:  BCF    06.4
.................... lcd_output_rw(0);         // RW = 0 - Ghi thong tin vao C.LCD.
0128:  BCF    03.5
0129:  BCF    06.3
012A:  BSF    03.5
012B:  BCF    06.3
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
012C:  BCF    03.5
012D:  BCF    06.2
012E:  BSF    03.5
012F:  BCF    06.2
.................... 
.................... delay_ms(15);   // Tao thoi gian tre 15ms (Thoi gian de LCD tu reset khi moi duoc cap nguon).
0130:  MOVLW  0F
0131:  MOVWF  5F
0132:  BCF    03.5
0133:  CALL   022
.................... 
.................... for(i=1;i<=3;i++)         // Doan lenh khoi dong C.LCD o che do 8 bit duoc thuc hien 3 lan lien tiep
0134:  MOVLW  01
0135:  MOVWF  30
0136:  MOVF   30,W
0137:  SUBLW  03
0138:  BTFSS  03.0
0139:  GOTO   146
....................    {                  // tai thoi diem ban dau (de dam bao cho C.LCD hoat dong on dinh trong 
....................    lcd_send_nibble(0x03);    // truong hop khi cung cap nguon cho C.LCD ma dien ap nguon tang len cham).
013A:  MOVLW  03
013B:  BSF    03.5
013C:  MOVWF  66
013D:  BCF    03.5
013E:  CALL   054
....................    delay_ms(5);         // RS = 0, RW = 0, D7 - D4 = 0011 (0x03) -> DL = 1 (8 bit).
013F:  MOVLW  05
0140:  BSF    03.5
0141:  MOVWF  5F
0142:  BCF    03.5
0143:  CALL   022
0144:  INCF   30,F
0145:  GOTO   136
....................    }                  // Do co BF (Busy Flag) chua kiem tra duoc trong thoi diem nay, nen phai 
....................                      // thuc hien 3 lan (xem luu do khoi dong C.LCD cua nha san xuat).
.................... 
.................... lcd_send_nibble(0x02);      // Doan lenh khoi dong C.LCD o che do 4 bit. Tu luc nay thi 4 bit cao duoc ghi
0146:  MOVLW  02
0147:  BSF    03.5
0148:  MOVWF  66
0149:  BCF    03.5
014A:  CALL   054
....................                      // ra truoc tien, sau do la 4 bit thap.
....................                      // RS = 0, RW = 0, D7 - D4 = 0010 (0x02) -> DL = 0 (4 bit).
....................                      // Co BF (Busy Flag) co the bat dau kiem tra duoc tu luc nay.
.................... 
.................... for(i=0;i<=3;i++)
014B:  CLRF   30
014C:  MOVF   30,W
014D:  SUBLW  03
014E:  BTFSS  03.0
014F:  GOTO   15D
....................    lcd_send_byte(0,LCD_INIT_STRING[i]);   // Goi ham truyen thong tin (lenh) sang C.LCD.
0150:  MOVF   30,W
0151:  CALL   004
0152:  MOVWF  31
0153:  BSF    03.5
0154:  CLRF   63
0155:  BCF    03.5
0156:  MOVF   31,W
0157:  BSF    03.5
0158:  MOVWF  64
0159:  BCF    03.5
015A:  CALL   0BF
015B:  INCF   30,F
015C:  GOTO   14C
015D:  BSF    0A.3
015E:  BCF    0A.4
015F:  GOTO   150 (RETURN)
.................... }                                 // Lenh: Thiet lap cau hinh hoat dong cho C.LCD.
.................... 
.................... // ***************************************************
.................... byte lcd_read_byte(void)   // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte low,high;
.................... // Dinh nghia ham.
.................... output_float(LCD_DATA4);   // Thiet lap chan port o che do ngo vao.
*
00C2:  BSF    08.7
.................... output_float(LCD_DATA5);
00C3:  BSF    08.6
.................... output_float(LCD_DATA6);
00C4:  BSF    08.5
.................... output_float(LCD_DATA7);
00C5:  BSF    08.4
.................... 
.................... lcd_output_rw(1);         // RW = 1 - Doc thong tin tu C.LCD.
00C6:  BCF    03.5
00C7:  BSF    06.3
00C8:  BSF    03.5
00C9:  BCF    06.3
....................                   // Tien hanh doc 4 bit cao cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00CA:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
00CB:  BCF    03.5
00CC:  BSF    06.2
00CD:  BSF    03.5
00CE:  BCF    06.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00CF:  NOP
.................... high = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit cao).
00D0:  BCF    03.5
00D1:  CALL   08C
00D2:  MOVF   78,W
00D3:  BSF    03.5
00D4:  MOVWF  66
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
00D5:  BCF    03.5
00D6:  BCF    06.2
00D7:  BSF    03.5
00D8:  BCF    06.2
....................                   // Tien hanh doc 4 bit thap cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00D9:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
00DA:  BCF    03.5
00DB:  BSF    06.2
00DC:  BSF    03.5
00DD:  BCF    06.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
00DE:  NOP
.................... low = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit thap).
00DF:  BCF    03.5
00E0:  CALL   08C
00E1:  MOVF   78,W
00E2:  BSF    03.5
00E3:  MOVWF  65
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
00E4:  BCF    03.5
00E5:  BCF    06.2
00E6:  BSF    03.5
00E7:  BCF    06.2
.................... 
.................... output_drive(LCD_DATA4);   // Thiet lap chan port o che do ngo ra.
00E8:  BCF    08.7
.................... output_drive(LCD_DATA5);
00E9:  BCF    08.6
.................... output_drive(LCD_DATA6);
00EA:  BCF    08.5
.................... output_drive(LCD_DATA7);
00EB:  BCF    08.4
.................... 
.................... return((high<<4) | low);   // Tra ve ket qua du lieu (dang 8 bit).
00EC:  SWAPF  66,W
00ED:  MOVWF  77
00EE:  MOVLW  F0
00EF:  ANDWF  77,F
00F0:  MOVF   77,W
00F1:  IORWF  65,W
00F2:  MOVWF  78
.................... }
.................... 
.................... // ***************************************************
.................... byte lcd_read_nibble(void)   // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
*
008C:  BSF    03.5
008D:  CLRF   67
.................... {
.................... // Khai bao bien.
.................... byte n = 0x00;   // Mac dinh gia tri ban dau cho noi chua se thong tin.
.................... // Dinh nghia ham.
.................... n |= input(LCD_DATA4);         // Doc lan luot cac bit tu bus du lieu.
008E:  BSF    08.7
008F:  MOVLW  00
0090:  BCF    03.5
0091:  BTFSC  08.7
0092:  MOVLW  01
0093:  BSF    03.5
0094:  IORWF  67,F
.................... n |= input(LCD_DATA5) << 1;
0095:  BSF    08.6
0096:  MOVLW  00
0097:  BCF    03.5
0098:  BTFSC  08.6
0099:  MOVLW  01
009A:  MOVWF  77
009B:  BCF    03.0
009C:  RLF    77,F
009D:  MOVF   77,W
009E:  BSF    03.5
009F:  IORWF  67,F
.................... n |= input(LCD_DATA6) << 2;
00A0:  BSF    08.5
00A1:  MOVLW  00
00A2:  BCF    03.5
00A3:  BTFSC  08.5
00A4:  MOVLW  01
00A5:  MOVWF  77
00A6:  RLF    77,F
00A7:  RLF    77,F
00A8:  MOVLW  FC
00A9:  ANDWF  77,F
00AA:  MOVF   77,W
00AB:  BSF    03.5
00AC:  IORWF  67,F
.................... n |= input(LCD_DATA7) << 3;
00AD:  BSF    08.4
00AE:  MOVLW  00
00AF:  BCF    03.5
00B0:  BTFSC  08.4
00B1:  MOVLW  01
00B2:  MOVWF  77
00B3:  RLF    77,F
00B4:  RLF    77,F
00B5:  RLF    77,F
00B6:  MOVLW  F8
00B7:  ANDWF  77,F
00B8:  MOVF   77,W
00B9:  BSF    03.5
00BA:  IORWF  67,F
.................... 
.................... return(n);   // Tra ve ket qua doc duoc (data = 0000 xxxx).
00BB:  MOVF   67,W
00BC:  MOVWF  78
00BD:  BCF    03.5
00BE:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_byte(byte address, byte n)   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... {                                 // address = 0: Lenh / 1: Du lieu.
....................                                  // byte = Thong tin can gui (8 bit).
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham.  
.................... lcd_output_rs(0);      // RS = 0 - Databus = Bus lenh.
00BF:  BCF    06.4
00C0:  BSF    03.5
00C1:  BCF    06.4
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
*
00F3:  MOVF   78,W
00F4:  MOVWF  65
00F5:  BTFSC  65.7
00F6:  GOTO   0C2
.................... lcd_output_rs(address);   // RS = address - Databus = Bus lenh/du lieu.
00F7:  MOVF   63,F
00F8:  BTFSS  03.2
00F9:  GOTO   0FE
00FA:  BCF    03.5
00FB:  BCF    06.4
00FC:  GOTO   100
00FD:  BSF    03.5
00FE:  BCF    03.5
00FF:  BSF    06.4
0100:  BSF    03.5
0101:  BCF    06.4
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0102:  NOP
.................... lcd_output_rw(0);      // RW = 0 - Ghi thong tin vao C.LCD.
0103:  BCF    03.5
0104:  BCF    06.3
0105:  BSF    03.5
0106:  BCF    06.3
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0107:  NOP
.................... lcd_output_enable(0);   // EN = 0 - Cam truy xuat C.LCD.
0108:  BCF    03.5
0109:  BCF    06.2
010A:  BSF    03.5
010B:  BCF    06.2
.................... lcd_send_nibble(n >> 4);   // Goi ham truyen 4 bit cao sang C.LCD.
010C:  SWAPF  64,W
010D:  MOVWF  65
010E:  MOVLW  0F
010F:  ANDWF  65,F
0110:  MOVF   65,W
0111:  MOVWF  66
0112:  BCF    03.5
0113:  CALL   054
.................... lcd_send_nibble(n & 0x0F);   // Goi ham truyen 4 bit thap sang C.LCD.
0114:  BSF    03.5
0115:  MOVF   64,W
0116:  ANDLW  0F
0117:  MOVWF  65
0118:  MOVWF  66
0119:  BCF    03.5
011A:  CALL   054
011B:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_nibble(byte n)   // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... {                        // n = Thong tin can gui. 4 bit can gui phai nam vi tri 4 bit thap.
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... output_bit(LCD_DATA4, bit_test(n, 0));   // Xuat lan luot cac bit len bus du lieu.
*
0054:  BSF    03.5
0055:  BTFSC  66.0
0056:  GOTO   05B
0057:  BCF    03.5
0058:  BCF    08.7
0059:  GOTO   05D
005A:  BSF    03.5
005B:  BCF    03.5
005C:  BSF    08.7
005D:  BSF    03.5
005E:  BCF    08.7
.................... output_bit(LCD_DATA5, bit_test(n, 1));
005F:  BTFSC  66.1
0060:  GOTO   065
0061:  BCF    03.5
0062:  BCF    08.6
0063:  GOTO   067
0064:  BSF    03.5
0065:  BCF    03.5
0066:  BSF    08.6
0067:  BSF    03.5
0068:  BCF    08.6
.................... output_bit(LCD_DATA6, bit_test(n, 2));
0069:  BTFSC  66.2
006A:  GOTO   06F
006B:  BCF    03.5
006C:  BCF    08.5
006D:  GOTO   071
006E:  BSF    03.5
006F:  BCF    03.5
0070:  BSF    08.5
0071:  BSF    03.5
0072:  BCF    08.5
.................... output_bit(LCD_DATA7, bit_test(n, 3));
0073:  BTFSC  66.3
0074:  GOTO   079
0075:  BCF    03.5
0076:  BCF    08.4
0077:  GOTO   07B
0078:  BSF    03.5
0079:  BCF    03.5
007A:  BSF    08.4
007B:  BSF    03.5
007C:  BCF    08.4
....................     
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
007D:  NOP
.................... lcd_output_enable(1);   // Tao xung ghi thong tin vao C.LCD.
007E:  BCF    03.5
007F:  BSF    06.2
0080:  BSF    03.5
0081:  BCF    06.2
.................... delay_us(2);         // Tao tre 2 chu ky (t=2us voi fosc=4MHz).
0082:  MOVLW  03
0083:  MOVWF  77
0084:  DECFSZ 77,F
0085:  GOTO   084
.................... lcd_output_enable(0);   // Tao xung ghi thong tin vao LCD - EN = 1->0 (High to Low).
0086:  BCF    03.5
0087:  BCF    06.2
0088:  BSF    03.5
0089:  BCF    06.2
008A:  BCF    03.5
008B:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_gotoxy(byte x, byte y)   // Ham thiet lap vi tri ghi tren C.LCD (Goc tren ben trai co toa do la 1,1).
.................... {
.................... // Khai bao bien.
.................... byte address;
.................... // Dinh nghia ham.  
.................... if(y==1)               // Kiem tra vi tri truy xuat thuoc hang 2.
*
0160:  BSF    03.5
0161:  DECFSZ 60,W
0162:  GOTO   165
....................    address=lcd_line_one;      // Nap dia chi RAM cua hang 2. 
0163:  CLRF   61
0164:  GOTO   179
.................... else if(y==2)      // Neu vi tri truy xuat thuoc hang 1.
0165:  MOVF   60,W
0166:  SUBLW  02
0167:  BTFSS  03.2
0168:  GOTO   16C
....................    address=lcd_line_two;      // Nap dia chi RAM cua hang 1.
0169:  MOVLW  40
016A:  MOVWF  61
016B:  GOTO   179
.................... else if(y==3)
016C:  MOVF   60,W
016D:  SUBLW  03
016E:  BTFSS  03.2
016F:  GOTO   173
....................    address=lcd_line_three;     
0170:  MOVLW  14
0171:  MOVWF  61
0172:  GOTO   179
.................... else if(y==4)
0173:  MOVF   60,W
0174:  SUBLW  04
0175:  BTFSS  03.2
0176:  GOTO   179
....................    address=lcd_line_four;   
0177:  MOVLW  54
0178:  MOVWF  61
.................... 
.................... address+=x-1;               // Ghep dia chi cot vao dia chi tong quat (address). address = address + (x-1).      
0179:  MOVLW  01
017A:  SUBWF  5F,W
017B:  ADDWF  61,F
....................                         // Ta qui uoc: Goc tren ben trai co toa do la 1,1 -> Cot dau tien la Cot 1
....................                         // (x-1) vi C.LCD qui uoc cot dau tien co dia chi la 0.
.................... lcd_send_byte(0,0x80|address);   // Goi ham truyen thong tin (lenh) sang C.LCD.
017C:  MOVF   61,W
017D:  IORLW  80
017E:  MOVWF  62
017F:  CLRF   63
0180:  MOVF   62,W
0181:  MOVWF  64
0182:  BCF    03.5
0183:  CALL   0BF
0184:  RETURN
.................... }                        // Lenh: Thiet lap dia chi DDRAM cua C.LCD (addresss).   
.................... 
.................... // ***************************************************
.................... char lcd_getc(byte x, byte y)   // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... char value;
.................... // Dinh nghia ham.  
.................... lcd_gotoxy(x,y);            // Xac dinh toa do C.LCD can truy xuat.
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
.................... lcd_output_rs(1);         // RS = 1 - Databus = Bus du lieu.
.................... value = lcd_read_byte();   // Doc ve tu C.LCD.
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
.................... 
.................... return(value);      // Tra ve ma ky tu tai toa do yeu cau.
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_putc(char c)   // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... switch (c)
0185:  BSF    03.5
0186:  MOVF   5E,W
0187:  XORLW  0C
0188:  BCF    03.5
0189:  BTFSC  03.2
018A:  GOTO   192
018B:  XORLW  06
018C:  BTFSC  03.2
018D:  GOTO   19E
018E:  XORLW  02
018F:  BTFSC  03.2
0190:  GOTO   1A6
0191:  GOTO   1AD
....................    {
....................    case '\f':     // Chuc nang xoa hien thi.
....................       lcd_send_byte(0,0x01);   // Goi ham truyen thong tin (lenh) sang C.LCD.
0192:  BSF    03.5
0193:  CLRF   63
0194:  MOVLW  01
0195:  MOVWF  64
0196:  BCF    03.5
0197:  CALL   0BF
....................       delay_ms(2);         // Lenh: Xoa hien thi tren man hinh C.LCD (0x01).
0198:  MOVLW  02
0199:  BSF    03.5
019A:  MOVWF  5F
019B:  BCF    03.5
019C:  CALL   022
....................       break;
019D:  GOTO   1B4
....................    case '\n':       // Chuc nang bat dau hang thu 2.
....................       lcd_gotoxy(1,0x02);     // Goi ham truyen thong tin (du lieu) sang C.LCD.   
019E:  MOVLW  01
019F:  BSF    03.5
01A0:  MOVWF  5F
01A1:  MOVLW  02
01A2:  MOVWF  60
01A3:  BCF    03.5
01A4:  CALL   160
....................       break;
01A5:  GOTO   1B4
....................     case '\b':       // Chuc nang lui ve 1 vi tri.
....................       lcd_send_byte(0,0x10);    // Goi ham truyen thong tin (lenh) sang C.LCD. 
01A6:  BSF    03.5
01A7:  CLRF   63
01A8:  MOVLW  10
01A9:  MOVWF  64
01AA:  BCF    03.5
01AB:  CALL   0BF
....................       break;               // Lenh: Doi con tro sang trai (0x10).
01AC:  GOTO   1B4
....................    default:       // Chuc nang hien thi ky tu c tai vi tri ke tiep tren C.LCD.
....................       lcd_send_byte(1,c);     // Goi ham truyen thong tin (du lieu) sang C.LCD.
01AD:  MOVLW  01
01AE:  BSF    03.5
01AF:  MOVWF  63
01B0:  MOVF   5E,W
01B1:  MOVWF  64
01B2:  BCF    03.5
01B3:  CALL   0BF
....................       break;
....................    }
01B4:  RETURN
.................... }      
.................... // ***************************************************   
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
02D2:  MOVF   5C,W
02D3:  MOVWF  5E
02D4:  MOVF   5B,W
02D5:  MOVWF  5D
02D6:  MOVF   5E,W
02D7:  MOVWF  7A
02D8:  MOVF   5D,W
02D9:  MOVWF  04
02DA:  BCF    03.7
02DB:  BTFSC  7A.0
02DC:  BSF    03.7
02DD:  MOVF   00,F
02DE:  BTFSC  03.2
02DF:  GOTO   2E4
02E0:  INCF   5D,F
02E1:  BTFSC  03.2
02E2:  INCF   5E,F
02E3:  GOTO   2D6
....................    return(sc - s);
02E4:  MOVF   5B,W
02E5:  SUBWF  5D,W
02E6:  MOVWF  77
02E7:  MOVF   5E,W
02E8:  MOVWF  7A
02E9:  MOVF   5C,W
02EA:  BTFSS  03.0
02EB:  INCFSZ 5C,W
02EC:  SUBWF  7A,F
02ED:  MOVF   77,W
02EE:  MOVWF  78
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0948:  BCF    03.5
0949:  CLRF   20
094A:  CLRF   21
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define ok       input(PIN_C2)
.................... #define up     input(PIN_C0)
.................... #define dw    input(PIN_C1)
.................... 
.................... #define BUZ PIN_C3
.................... 
.................... #include "DS18B20_lib.c"
.................... 
.................... #define DS18B20_PIN PIN_A0
.................... signed int16 raw_temp;
.................... float temp;
.................... 
.................... int1 DS18B20_start(){
....................     output_low(DS18B20_PIN);        // Send reset pulse to the DS18B20 sensor
*
0365:  BSF    03.5
0366:  BCF    05.0
0367:  BCF    03.5
0368:  BCF    05.0
....................     output_drive(DS18B20_PIN);      // Configure DS18B20 pin as output
0369:  BSF    03.5
036A:  BCF    05.0
....................     delay_us(500);                  // Wait 500 us
036B:  MOVLW  02
036C:  BCF    03.5
036D:  MOVWF  32
036E:  MOVLW  F9
036F:  MOVWF  33
0370:  CALL   356
0371:  DECFSZ 32,F
0372:  GOTO   36E
....................     output_float(DS18B20_PIN);      // Configure DS18B20 pin as input
0373:  BSF    03.5
0374:  BSF    05.0
....................     delay_us(100);                  // Wait to read the DS18B20 sensor response
0375:  MOVLW  A6
0376:  MOVWF  77
0377:  DECFSZ 77,F
0378:  GOTO   377
0379:  NOP
....................     if(!input(DS18B20_PIN)){
037A:  BSF    05.0
037B:  BCF    03.5
037C:  BTFSC  05.0
037D:  GOTO   388
....................         delay_us(400);              // Wait 400 us
037E:  MOVLW  02
037F:  MOVWF  32
0380:  MOVLW  C7
0381:  MOVWF  33
0382:  CALL   356
0383:  DECFSZ 32,F
0384:  GOTO   380
....................         return TRUE;                // DS18B20 sensor is present
0385:  MOVLW  01
0386:  MOVWF  78
0387:  GOTO   38A
....................     }
....................     return FALSE;
0388:  MOVLW  00
0389:  MOVWF  78
038A:  RETURN
.................... }
.................... 
.................... void DS18B20_write_bit(int1 value){
....................     output_low(DS18B20_PIN);
*
03A0:  BSF    03.5
03A1:  BCF    05.0
03A2:  BCF    03.5
03A3:  BCF    05.0
....................     output_drive(DS18B20_PIN);      // Configure DS18B20 pin as output
03A4:  BSF    03.5
03A5:  BCF    05.0
....................     delay_us(2);                    // Wait 2 us
03A6:  MOVLW  03
03A7:  MOVWF  77
03A8:  DECFSZ 77,F
03A9:  GOTO   3A8
....................     output_bit(DS18B20_PIN, value); 
03AA:  BCF    03.5
03AB:  MOVF   35,F
03AC:  BTFSS  03.2
03AD:  GOTO   3B0
03AE:  BCF    05.0
03AF:  GOTO   3B1
03B0:  BSF    05.0
03B1:  BSF    03.5
03B2:  BCF    05.0
....................     delay_us(80);                   // Wait 80 us
03B3:  MOVLW  85
03B4:  MOVWF  77
03B5:  DECFSZ 77,F
03B6:  GOTO   3B5
....................     output_float(DS18B20_PIN);      // Configure DS18B20 pin as input
03B7:  BSF    05.0
....................     delay_us(2);                    // Wait 2 us
03B8:  MOVLW  03
03B9:  MOVWF  77
03BA:  DECFSZ 77,F
03BB:  GOTO   3BA
.................... }
.................... 
.................... void DS18B20_write_byte(int8 value){
....................     int8 i;
....................     for(i = 0; i < 8; i++){
*
038B:  CLRF   33
038C:  MOVF   33,W
038D:  SUBLW  07
038E:  BTFSS  03.0
038F:  GOTO   3BF
....................         DS18B20_write_bit(bit_test(value,i));
0390:  MOVF   32,W
0391:  MOVWF  77
0392:  MOVF   33,W
0393:  MOVWF  78
0394:  BTFSC  03.2
0395:  GOTO   39A
0396:  BCF    03.0
0397:  RRF    77,F
0398:  DECFSZ 78,F
0399:  GOTO   396
039A:  MOVLW  00
039B:  BTFSC  77.0
039C:  MOVLW  01
039D:  MOVWF  34
039E:  MOVF   34,W
039F:  MOVWF  35
*
03BC:  BCF    03.5
03BD:  INCF   33,F
03BE:  GOTO   38C
....................     }
03BF:  RETURN
.................... }
.................... 
.................... int1 DS18B20_read_bit(void){
....................     int1 value;
....................     output_low(DS18B20_PIN);
*
03C6:  BSF    03.5
03C7:  BCF    05.0
03C8:  BCF    03.5
03C9:  BCF    05.0
....................     output_drive(DS18B20_PIN);
03CA:  BSF    03.5
03CB:  BCF    05.0
....................     delay_us(2);
03CC:  MOVLW  03
03CD:  MOVWF  77
03CE:  DECFSZ 77,F
03CF:  GOTO   3CE
....................     output_float(DS18B20_PIN);
03D0:  BSF    05.0
....................     delay_us(5);
03D1:  MOVLW  08
03D2:  MOVWF  77
03D3:  DECFSZ 77,F
03D4:  GOTO   3D3
....................     value = input(DS18B20_PIN);
03D5:  BSF    05.0
03D6:  BCF    03.5
03D7:  BCF    38.0
03D8:  BTFSC  05.0
03D9:  BSF    38.0
....................     delay_us(100);
03DA:  MOVLW  A6
03DB:  MOVWF  77
03DC:  DECFSZ 77,F
03DD:  GOTO   3DC
03DE:  NOP
....................     return value;
03DF:  MOVLW  00
03E0:  BTFSC  38.0
03E1:  MOVLW  01
03E2:  MOVWF  78
.................... }
.................... 
.................... int8 DS18B20_read_byte(void){
*
03C0:  CLRF   37
....................     int8 i, value = 0;
....................     for(i = 0; i < 8; i++){
03C1:  CLRF   36
03C2:  MOVF   36,W
03C3:  SUBLW  07
03C4:  BTFSS  03.0
03C5:  GOTO   3EC
....................         shift_right(&value, 1, DS18B20_read_bit());
*
03E3:  MOVF   78,F
03E4:  BTFSS  03.2
03E5:  GOTO   3E8
03E6:  BCF    03.0
03E7:  GOTO   3E9
03E8:  BSF    03.0
03E9:  RRF    37,F
03EA:  INCF   36,F
03EB:  GOTO   3C2
....................     }
....................     return value;
03EC:  MOVF   37,W
03ED:  MOVWF  78
03EE:  RETURN
.................... }
.................... 
.................... int1 DS18B20_read(int16 *raw_temp_value) {
....................     if(!DS18B20_start()){
*
05F9:  CALL   365
05FA:  MOVF   78,F
05FB:  BTFSS  03.2
05FC:  GOTO   600
....................         return FALSE;
05FD:  MOVLW  00
05FE:  MOVWF  78
05FF:  GOTO   64E
....................     }
....................     DS18B20_write_byte(0xCC);
0600:  MOVLW  CC
0601:  MOVWF  32
0602:  CALL   38B
....................     DS18B20_write_byte(0x44);
0603:  MOVLW  44
0604:  MOVWF  32
0605:  CALL   38B
....................     while(DS18B20_read_byte() == 0);
0606:  CALL   3C0
0607:  MOVF   78,F
0608:  BTFSC  03.2
0609:  GOTO   606
....................     if(!DS18B20_start()){
060A:  CALL   365
060B:  MOVF   78,F
060C:  BTFSS  03.2
060D:  GOTO   611
....................         return FALSE;
060E:  MOVLW  00
060F:  MOVWF  78
0610:  GOTO   64E
....................     }
....................     DS18B20_write_byte(0xCC);
0611:  MOVLW  CC
0612:  MOVWF  32
0613:  CALL   38B
....................     DS18B20_write_byte(0xBE);
0614:  MOVLW  BE
0615:  MOVWF  32
0616:  CALL   38B
....................     *raw_temp_value = DS18B20_read_byte();
0617:  MOVF   31,W
0618:  MOVWF  7A
0619:  MOVF   30,W
061A:  MOVWF  32
061B:  MOVF   31,W
061C:  MOVWF  33
061D:  CALL   3C0
061E:  MOVF   32,W
061F:  MOVWF  04
0620:  BCF    03.7
0621:  BTFSC  33.0
0622:  BSF    03.7
0623:  INCF   04,F
0624:  CLRF   00
0625:  DECF   04,F
0626:  MOVF   78,W
0627:  MOVWF  00
.................... 
....................     *raw_temp_value |= (int16)(DS18B20_read_byte()) << 8;
0628:  MOVF   31,W
0629:  MOVWF  7A
062A:  MOVF   30,W
062B:  MOVWF  32
062C:  MOVF   31,W
062D:  MOVWF  33
062E:  MOVF   30,W
062F:  MOVWF  04
0630:  BCF    03.7
0631:  BTFSC  31.0
0632:  BSF    03.7
0633:  INCF   04,F
0634:  MOVF   00,W
0635:  MOVWF  35
0636:  DECF   04,F
0637:  MOVF   00,W
0638:  MOVWF  34
0639:  CALL   3C0
063A:  CLRF   37
063B:  MOVLW  00
063C:  IORWF  34,W
063D:  MOVWF  77
063E:  MOVF   78,W
063F:  IORWF  35,W
0640:  MOVWF  7A
0641:  MOVF   32,W
0642:  MOVWF  04
0643:  BCF    03.7
0644:  BTFSC  33.0
0645:  BSF    03.7
0646:  INCF   04,F
0647:  MOVF   7A,W
0648:  MOVWF  00
0649:  DECF   04,F
064A:  MOVF   77,W
064B:  MOVWF  00
.................... 
....................     return TRUE;
064C:  MOVLW  01
064D:  MOVWF  78
.................... }
.................... 
.................... 
.................... unsigned int16 nhietdo;
.................... unsigned int gtmin = 30, gtmax = 32;
.................... int1 alarm = 1;
.................... 
.................... void xuly_alarm(){
....................    if(alarm == 1){
*
07B6:  BTFSS  2C.0
07B7:  GOTO   7DB
....................       if(nhietdo >= gtmax){
07B8:  MOVF   29,F
07B9:  BTFSS  03.2
07BA:  GOTO   7BF
07BB:  MOVF   2B,W
07BC:  SUBWF  28,W
07BD:  BTFSS  03.0
07BE:  GOTO   7C6
....................          output_high(BUZ);
07BF:  BCF    2D.3
07C0:  MOVF   2D,W
07C1:  BSF    03.5
07C2:  MOVWF  07
07C3:  BCF    03.5
07C4:  BSF    07.3
....................       }
07C5:  GOTO   7DA
....................       else if(nhietdo <= gtmin){
07C6:  MOVF   29,F
07C7:  BTFSS  03.2
07C8:  GOTO   7D4
07C9:  MOVF   28,W
07CA:  SUBWF  2A,W
07CB:  BTFSS  03.0
07CC:  GOTO   7D4
....................          output_high(BUZ);
07CD:  BCF    2D.3
07CE:  MOVF   2D,W
07CF:  BSF    03.5
07D0:  MOVWF  07
07D1:  BCF    03.5
07D2:  BSF    07.3
....................       }
07D3:  GOTO   7DA
....................       else{
....................          output_low(BUZ);
07D4:  BCF    2D.3
07D5:  MOVF   2D,W
07D6:  BSF    03.5
07D7:  MOVWF  07
07D8:  BCF    03.5
07D9:  BCF    07.3
....................       }
....................    }
07DA:  GOTO   7E3
....................    else if(alarm == 0){
07DB:  BTFSC  2C.0
07DC:  GOTO   7E3
....................       output_low(BUZ);
07DD:  BCF    2D.3
07DE:  MOVF   2D,W
07DF:  BSF    03.5
07E0:  MOVWF  07
07E1:  BCF    03.5
07E2:  BCF    07.3
....................    }
.................... }
.................... 
.................... void xuly_nhietdo(){
....................     if(DS18B20_read(&raw_temp)){
*
05F6:  CLRF   31
05F7:  MOVLW  22
05F8:  MOVWF  30
*
064E:  MOVF   78,F
064F:  BTFSC  03.2
0650:  GOTO   7A8
....................         temp = (float)raw_temp/16;
0651:  MOVF   23,W
0652:  MOVWF  31
0653:  MOVF   22,W
0654:  MOVWF  30
*
0679:  MOVF   7A,W
067A:  MOVWF  33
067B:  MOVF   79,W
067C:  MOVWF  32
067D:  MOVF   78,W
067E:  MOVWF  31
067F:  MOVF   77,W
0680:  MOVWF  30
0681:  MOVF   33,W
0682:  MOVWF  37
0683:  MOVF   32,W
0684:  MOVWF  36
0685:  MOVF   31,W
0686:  MOVWF  35
0687:  MOVF   30,W
0688:  MOVWF  34
0689:  CLRF   3B
068A:  CLRF   3A
068B:  CLRF   39
068C:  MOVLW  83
068D:  MOVWF  38
*
0757:  MOVF   7A,W
0758:  MOVWF  27
0759:  MOVF   79,W
075A:  MOVWF  26
075B:  MOVF   78,W
075C:  MOVWF  25
075D:  MOVF   77,W
075E:  MOVWF  24
....................         nhietdo = temp;
075F:  MOVF   27,W
0760:  MOVWF  33
0761:  MOVF   26,W
0762:  MOVWF  32
0763:  MOVF   25,W
0764:  MOVWF  31
0765:  MOVF   24,W
0766:  MOVWF  30
*
0785:  MOVF   79,W
0786:  MOVWF  29
0787:  MOVF   78,W
0788:  MOVWF  28
....................         lcd_gotoxy(7,1);
0789:  MOVLW  07
078A:  BSF    03.5
078B:  MOVWF  5F
078C:  MOVLW  01
078D:  MOVWF  60
078E:  BCF    03.5
078F:  CALL   160
....................         printf(lcd_putc, "Temp: %f", temp);
0790:  MOVLW  0C
0791:  BSF    03.6
0792:  MOVWF  0D
0793:  MOVLW  00
0794:  MOVWF  0F
0795:  BCF    03.0
0796:  MOVLW  06
0797:  BCF    03.6
0798:  MOVWF  30
0799:  CALL   3EF
079A:  MOVLW  89
079B:  MOVWF  04
079C:  MOVF   27,W
079D:  MOVWF  33
079E:  MOVF   26,W
079F:  MOVWF  32
07A0:  MOVF   25,W
07A1:  MOVWF  31
07A2:  MOVF   24,W
07A3:  MOVWF  30
07A4:  MOVLW  02
07A5:  MOVWF  34
07A6:  GOTO   499
....................     }
07A7:  GOTO   7B6
....................     else {
....................         lcd_gotoxy(7,1);
07A8:  MOVLW  07
07A9:  BSF    03.5
07AA:  MOVWF  5F
07AB:  MOVLW  01
07AC:  MOVWF  60
07AD:  BCF    03.5
07AE:  CALL   160
....................         lcd_putc("Error");
07AF:  MOVLW  11
07B0:  BSF    03.6
07B1:  MOVWF  0D
07B2:  MOVLW  00
07B3:  MOVWF  0F
07B4:  BCF    03.6
07B5:  CALL   1B5
....................     }
....................     xuly_alarm();
*
07E3:  BSF    0A.3
07E4:  BCF    0A.4
07E5:  GOTO   15F (RETURN)
.................... }
.................... 
.................... void hienthi_thongtin(void){
....................     char Tri[] = {"                LAM QUANG TRI-19151087                 "};
*
0229:  MOVLW  20
022A:  MOVWF  30
022B:  MOVWF  31
022C:  MOVWF  32
022D:  MOVWF  33
022E:  MOVWF  34
022F:  MOVWF  35
0230:  MOVWF  36
0231:  MOVWF  37
0232:  MOVWF  38
0233:  MOVWF  39
0234:  MOVWF  3A
0235:  MOVWF  3B
0236:  MOVWF  3C
0237:  MOVWF  3D
0238:  MOVWF  3E
0239:  MOVWF  3F
023A:  MOVLW  4C
023B:  MOVWF  40
023C:  MOVLW  41
023D:  MOVWF  41
023E:  MOVLW  4D
023F:  MOVWF  42
0240:  MOVLW  20
0241:  MOVWF  43
0242:  MOVLW  51
0243:  MOVWF  44
0244:  MOVLW  55
0245:  MOVWF  45
0246:  MOVLW  41
0247:  MOVWF  46
0248:  MOVLW  4E
0249:  MOVWF  47
024A:  MOVLW  47
024B:  MOVWF  48
024C:  MOVLW  20
024D:  MOVWF  49
024E:  MOVLW  54
024F:  MOVWF  4A
0250:  MOVLW  52
0251:  MOVWF  4B
0252:  MOVLW  49
0253:  MOVWF  4C
0254:  MOVLW  2D
0255:  MOVWF  4D
0256:  MOVLW  31
0257:  MOVWF  4E
0258:  MOVLW  39
0259:  MOVWF  4F
025A:  MOVLW  31
025B:  MOVWF  50
025C:  MOVLW  35
025D:  MOVWF  51
025E:  MOVLW  31
025F:  MOVWF  52
0260:  MOVLW  30
0261:  MOVWF  53
0262:  MOVLW  38
0263:  MOVWF  54
0264:  MOVLW  37
0265:  MOVWF  55
0266:  MOVLW  20
0267:  MOVWF  56
0268:  MOVWF  57
0269:  MOVWF  58
026A:  MOVWF  59
026B:  MOVWF  5A
026C:  MOVWF  5B
026D:  MOVWF  5C
026E:  MOVWF  5D
026F:  MOVWF  5E
0270:  MOVWF  5F
0271:  MOVWF  60
0272:  MOVWF  61
0273:  MOVWF  62
0274:  MOVWF  63
0275:  MOVWF  64
0276:  MOVWF  65
0277:  MOVWF  66
0278:  CLRF   67
....................     char An[] = {"                NGUYEN DINH AN-19151068                 "};
0279:  BSF    03.5
027A:  MOVWF  20
027B:  MOVWF  21
027C:  MOVWF  22
027D:  MOVWF  23
027E:  MOVWF  24
027F:  MOVWF  25
0280:  MOVWF  26
0281:  MOVWF  27
0282:  MOVWF  28
0283:  MOVWF  29
0284:  MOVWF  2A
0285:  MOVWF  2B
0286:  MOVWF  2C
0287:  MOVWF  2D
0288:  MOVWF  2E
0289:  MOVWF  2F
028A:  MOVLW  4E
028B:  MOVWF  30
028C:  MOVLW  47
028D:  MOVWF  31
028E:  MOVLW  55
028F:  MOVWF  32
0290:  MOVLW  59
0291:  MOVWF  33
0292:  MOVLW  45
0293:  MOVWF  34
0294:  MOVLW  4E
0295:  MOVWF  35
0296:  MOVLW  20
0297:  MOVWF  36
0298:  MOVLW  44
0299:  MOVWF  37
029A:  MOVLW  49
029B:  MOVWF  38
029C:  MOVLW  4E
029D:  MOVWF  39
029E:  MOVLW  48
029F:  MOVWF  3A
02A0:  MOVLW  20
02A1:  MOVWF  3B
02A2:  MOVLW  41
02A3:  MOVWF  3C
02A4:  MOVLW  4E
02A5:  MOVWF  3D
02A6:  MOVLW  2D
02A7:  MOVWF  3E
02A8:  MOVLW  31
02A9:  MOVWF  3F
02AA:  MOVLW  39
02AB:  MOVWF  40
02AC:  MOVLW  31
02AD:  MOVWF  41
02AE:  MOVLW  35
02AF:  MOVWF  42
02B0:  MOVLW  31
02B1:  MOVWF  43
02B2:  MOVLW  30
02B3:  MOVWF  44
02B4:  MOVLW  36
02B5:  MOVWF  45
02B6:  MOVLW  38
02B7:  MOVWF  46
02B8:  MOVLW  20
02B9:  MOVWF  47
02BA:  MOVWF  48
02BB:  MOVWF  49
02BC:  MOVWF  4A
02BD:  MOVWF  4B
02BE:  MOVWF  4C
02BF:  MOVWF  4D
02C0:  MOVWF  4E
02C1:  MOVWF  4F
02C2:  MOVWF  50
02C3:  MOVWF  51
02C4:  MOVWF  52
02C5:  MOVWF  53
02C6:  MOVWF  54
02C7:  MOVWF  55
02C8:  MOVWF  56
02C9:  MOVWF  57
02CA:  CLRF   58
....................     signed char i,j;
....................     
....................     for (j = 1; j <= strlen(Tri) - 16; j++)
02CB:  MOVLW  01
02CC:  BCF    03.5
02CD:  MOVWF  69
02CE:  BSF    03.5
02CF:  CLRF   5C
02D0:  MOVLW  30
02D1:  MOVWF  5B
*
02EF:  MOVLW  10
02F0:  SUBWF  78,W
02F1:  BCF    03.5
02F2:  BTFSC  69.7
02F3:  GOTO   2F9
02F4:  SUBWF  69,W
02F5:  BTFSC  03.2
02F6:  GOTO   2F9
02F7:  BTFSC  03.0
02F8:  GOTO   34A
....................     {
....................         for(i = 1; i <= 16; i++)
02F9:  MOVLW  01
02FA:  MOVWF  68
02FB:  BTFSC  68.7
02FC:  GOTO   301
02FD:  MOVF   68,W
02FE:  SUBLW  10
02FF:  BTFSS  03.0
0300:  GOTO   329
....................         {
....................             lcd_gotoxy(i,1);
0301:  MOVF   68,W
0302:  BSF    03.5
0303:  MOVWF  5F
0304:  MOVLW  01
0305:  MOVWF  60
0306:  BCF    03.5
0307:  CALL   160
....................             printf(lcd_putc,"%c",Tri[i + j - 1]);
0308:  MOVF   69,W
0309:  ADDWF  68,W
030A:  ADDLW  FF
030B:  ADDLW  30
030C:  MOVWF  04
030D:  BCF    03.7
030E:  MOVF   00,W
030F:  MOVWF  6A
0310:  BSF    03.5
0311:  MOVWF  5E
0312:  BCF    03.5
0313:  CALL   185
....................             lcd_gotoxy(i,2);
0314:  MOVF   68,W
0315:  BSF    03.5
0316:  MOVWF  5F
0317:  MOVLW  02
0318:  MOVWF  60
0319:  BCF    03.5
031A:  CALL   160
....................             printf(lcd_putc,"%c",An[i + j - 1]);
031B:  MOVF   69,W
031C:  ADDWF  68,W
031D:  ADDLW  FF
031E:  ADDLW  A0
031F:  MOVWF  04
0320:  BCF    03.7
0321:  MOVF   00,W
0322:  MOVWF  6A
0323:  BSF    03.5
0324:  MOVWF  5E
0325:  BCF    03.5
0326:  CALL   185
0327:  INCF   68,F
0328:  GOTO   2FB
....................         }
....................         delay_ms(300);
0329:  MOVLW  02
032A:  MOVWF  6A
032B:  MOVLW  96
032C:  BSF    03.5
032D:  MOVWF  5F
032E:  BCF    03.5
032F:  CALL   022
0330:  DECFSZ 6A,F
0331:  GOTO   32B
....................         if(!ok == 1){
0332:  BSF    2D.2
0333:  MOVF   2D,W
0334:  BSF    03.5
0335:  MOVWF  07
0336:  BCF    03.5
0337:  BTFSC  07.2
0338:  GOTO   348
....................             while(!ok == 1);
0339:  BSF    2D.2
033A:  MOVF   2D,W
033B:  BSF    03.5
033C:  MOVWF  07
033D:  BCF    03.5
033E:  BTFSS  07.2
033F:  GOTO   339
....................             lcd_putc("\f");
0340:  MOVLW  14
0341:  BSF    03.6
0342:  MOVWF  0D
0343:  MOVLW  00
0344:  MOVWF  0F
0345:  BCF    03.6
0346:  CALL   1B5
....................             break;
0347:  GOTO   34A
....................          }
0348:  INCF   69,F
0349:  GOTO   2CE
....................     }
....................     delay_ms(1000);
034A:  MOVLW  04
034B:  MOVWF  6A
034C:  MOVLW  FA
034D:  BSF    03.5
034E:  MOVWF  5F
034F:  BCF    03.5
0350:  CALL   022
0351:  DECFSZ 6A,F
0352:  GOTO   34C
0353:  BSF    0A.3
0354:  BCF    0A.4
0355:  GOTO   15C (RETURN)
.................... }
.................... 
.................... void hienthi_gioihan(){
....................    lcd_gotoxy(1,2);
*
08D4:  MOVLW  01
08D5:  BSF    03.5
08D6:  MOVWF  5F
08D7:  MOVLW  02
08D8:  MOVWF  60
08D9:  BCF    0A.3
08DA:  BCF    03.5
08DB:  CALL   160
08DC:  BSF    0A.3
....................    printf(lcd_putc, "Max: %d", gtmax);
08DD:  MOVLW  15
08DE:  BSF    03.6
08DF:  MOVWF  0D
08E0:  MOVLW  00
08E1:  MOVWF  0F
08E2:  BCF    03.0
08E3:  MOVLW  05
08E4:  BCF    03.6
08E5:  MOVWF  30
08E6:  BCF    0A.3
08E7:  CALL   3EF
08E8:  BSF    0A.3
08E9:  MOVF   2B,W
08EA:  MOVWF  30
08EB:  MOVLW  18
08EC:  MOVWF  31
08ED:  CALL   000
....................    lcd_gotoxy(9,2);
08EE:  MOVLW  09
08EF:  BSF    03.5
08F0:  MOVWF  5F
08F1:  MOVLW  02
08F2:  MOVWF  60
08F3:  BCF    0A.3
08F4:  BCF    03.5
08F5:  CALL   160
08F6:  BSF    0A.3
....................    printf(lcd_putc,"Min: %d",gtmin);
08F7:  MOVLW  19
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  00
08FB:  MOVWF  0F
08FC:  BCF    03.0
08FD:  MOVLW  05
08FE:  BCF    03.6
08FF:  MOVWF  30
0900:  BCF    0A.3
0901:  CALL   3EF
0902:  BSF    0A.3
0903:  MOVF   2A,W
0904:  MOVWF  30
0905:  MOVLW  18
0906:  MOVWF  31
0907:  CALL   000
....................    if(alarm == 1){
0908:  BTFSS  2C.0
0909:  GOTO   11D
....................       lcd_gotoxy(14,1);
090A:  MOVLW  0E
090B:  BSF    03.5
090C:  MOVWF  5F
090D:  MOVLW  01
090E:  MOVWF  60
090F:  BCF    0A.3
0910:  BCF    03.5
0911:  CALL   160
0912:  BSF    0A.3
....................       lcd_putc("AL");
0913:  MOVLW  1D
0914:  BSF    03.6
0915:  MOVWF  0D
0916:  MOVLW  00
0917:  MOVWF  0F
0918:  BCF    0A.3
0919:  BCF    03.6
091A:  CALL   1B5
091B:  BSF    0A.3
....................    }
091C:  GOTO   131
....................    else if(alarm == 0){
091D:  BTFSC  2C.0
091E:  GOTO   131
....................       lcd_gotoxy(14,1);
091F:  MOVLW  0E
0920:  BSF    03.5
0921:  MOVWF  5F
0922:  MOVLW  01
0923:  MOVWF  60
0924:  BCF    0A.3
0925:  BCF    03.5
0926:  CALL   160
0927:  BSF    0A.3
....................       lcd_putc("  ");
0928:  MOVLW  1F
0929:  BSF    03.6
092A:  MOVWF  0D
092B:  MOVLW  00
092C:  MOVWF  0F
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   1B5
0930:  BSF    0A.3
....................    }
.................... }
.................... 
.................... void ktra_nutnhan(){
....................     if(!up == 1)
*
086B:  BSF    2D.0
086C:  MOVF   2D,W
086D:  BSF    03.5
086E:  MOVWF  07
086F:  BCF    03.5
0870:  BTFSC  07.0
0871:  GOTO   08F
....................     {
....................         delay_ms(5);
0872:  MOVLW  05
0873:  BSF    03.5
0874:  MOVWF  5F
0875:  BCF    0A.3
0876:  BCF    03.5
0877:  CALL   022
0878:  BSF    0A.3
....................         if(!up == 1)
0879:  BSF    2D.0
087A:  MOVF   2D,W
087B:  BSF    03.5
087C:  MOVWF  07
087D:  BCF    03.5
087E:  BTFSC  07.0
087F:  GOTO   08F
....................         {
....................             while (!up == 1);
0880:  BSF    2D.0
0881:  MOVF   2D,W
0882:  BSF    03.5
0883:  MOVWF  07
0884:  BCF    03.5
0885:  BTFSS  07.0
0886:  GOTO   080
....................             if(gtmax > 40)
0887:  MOVF   2B,W
0888:  SUBLW  28
0889:  BTFSC  03.0
088A:  GOTO   08E
....................             {
....................                 gtmax = 20;
088B:  MOVLW  14
088C:  MOVWF  2B
....................             }
088D:  GOTO   08F
....................             else{
....................                 gtmax++;
088E:  INCF   2B,F
....................             }
....................         }
....................     }
....................     if(!dw == 1)
088F:  BSF    2D.1
0890:  MOVF   2D,W
0891:  BSF    03.5
0892:  MOVWF  07
0893:  BCF    03.5
0894:  BTFSC  07.1
0895:  GOTO   0B3
....................     {
....................         delay_ms(5);
0896:  MOVLW  05
0897:  BSF    03.5
0898:  MOVWF  5F
0899:  BCF    0A.3
089A:  BCF    03.5
089B:  CALL   022
089C:  BSF    0A.3
....................         if(!dw == 1)
089D:  BSF    2D.1
089E:  MOVF   2D,W
089F:  BSF    03.5
08A0:  MOVWF  07
08A1:  BCF    03.5
08A2:  BTFSC  07.1
08A3:  GOTO   0B3
....................         {
....................             if(gtmin > 40)
08A4:  MOVF   2A,W
08A5:  SUBLW  28
08A6:  BTFSC  03.0
08A7:  GOTO   0AB
....................             {
....................                 gtmin = 20;
08A8:  MOVLW  14
08A9:  MOVWF  2A
....................             }
08AA:  GOTO   0AC
....................             else{
....................                 gtmin++;
08AB:  INCF   2A,F
....................             }
....................             while (!dw == 1);
08AC:  BSF    2D.1
08AD:  MOVF   2D,W
08AE:  BSF    03.5
08AF:  MOVWF  07
08B0:  BCF    03.5
08B1:  BTFSS  07.1
08B2:  GOTO   0AC
....................         }
....................     }
....................     if(!ok == 1)
08B3:  BSF    2D.2
08B4:  MOVF   2D,W
08B5:  BSF    03.5
08B6:  MOVWF  07
08B7:  BCF    03.5
08B8:  BTFSC  07.2
08B9:  GOTO   0D4
....................     {
....................         delay_ms(5);
08BA:  MOVLW  05
08BB:  BSF    03.5
08BC:  MOVWF  5F
08BD:  BCF    0A.3
08BE:  BCF    03.5
08BF:  CALL   022
08C0:  BSF    0A.3
....................         if(!ok == 1)
08C1:  BSF    2D.2
08C2:  MOVF   2D,W
08C3:  BSF    03.5
08C4:  MOVWF  07
08C5:  BCF    03.5
08C6:  BTFSC  07.2
08C7:  GOTO   0D4
....................         {
....................             if(alarm == 0)
08C8:  BTFSC  2C.0
08C9:  GOTO   0CC
....................             {
....................                 alarm = 1;
08CA:  BSF    2C.0
....................             }
08CB:  GOTO   0CD
....................             else{
....................                 alarm = 0;
08CC:  BCF    2C.0
....................             }
....................             while (!ok == 1);
08CD:  BSF    2D.2
08CE:  MOVF   2D,W
08CF:  BSF    03.5
08D0:  MOVWF  07
08D1:  BCF    03.5
08D2:  BTFSS  07.2
08D3:  GOTO   0CD
....................         }
....................     }
....................     hienthi_gioihan();
*
0931:  BSF    0A.3
0932:  BCF    0A.4
0933:  GOTO   161 (RETURN)
.................... }
.................... void start(){
....................     output_low(BUZ);
*
0036:  BCF    2D.3
0037:  MOVF   2D,W
0038:  BSF    03.5
0039:  MOVWF  07
003A:  BCF    03.5
003B:  BCF    07.3
....................     output_high(BUZ);
003C:  BCF    2D.3
003D:  MOVF   2D,W
003E:  BSF    03.5
003F:  MOVWF  07
0040:  BCF    03.5
0041:  BSF    07.3
....................     delay_ms(500);
0042:  MOVLW  02
0043:  MOVWF  30
0044:  MOVLW  FA
0045:  BSF    03.5
0046:  MOVWF  5F
0047:  BCF    03.5
0048:  CALL   022
0049:  DECFSZ 30,F
004A:  GOTO   044
....................     output_low(BUZ);
004B:  BCF    2D.3
004C:  MOVF   2D,W
004D:  BSF    03.5
004E:  MOVWF  07
004F:  BCF    03.5
0050:  BCF    07.3
0051:  BSF    0A.3
0052:  BCF    0A.4
0053:  GOTO   14D (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void main(){
*
0934:  MOVF   03,W
0935:  ANDLW  1F
0936:  MOVWF  03
0937:  MOVLW  1E
0938:  MOVWF  2A
0939:  MOVLW  20
093A:  MOVWF  2B
093B:  BSF    2C.0
093C:  MOVLW  FF
093D:  MOVWF  2D
093E:  CLRF   2F
093F:  CLRF   2E
0940:  BSF    03.5
0941:  BSF    1F.0
0942:  BSF    1F.1
0943:  BSF    1F.2
0944:  BCF    1F.3
0945:  MOVLW  07
0946:  MOVWF  1C
0947:  BCF    03.7
....................     start();
*
094B:  BCF    0A.3
094C:  GOTO   036
094D:  BSF    0A.3
....................     lcd_init();
094E:  BCF    0A.3
094F:  GOTO   11C
0950:  BSF    0A.3
....................     lcd_putc("\f");
0951:  MOVLW  21
0952:  BSF    03.6
0953:  MOVWF  0D
0954:  MOVLW  00
0955:  MOVWF  0F
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   1B5
0959:  BSF    0A.3
....................     hienthi_thongtin();
095A:  BCF    0A.3
095B:  GOTO   229
095C:  BSF    0A.3
....................     while(true){
....................         xuly_nhietdo();
095D:  BCF    0A.3
095E:  GOTO   5F6
095F:  BSF    0A.3
....................         ktra_nutnhan();
0960:  GOTO   06B
....................         delay_ms(200);
0961:  MOVLW  C8
0962:  BSF    03.5
0963:  MOVWF  5F
0964:  BCF    0A.3
0965:  BCF    03.5
0966:  CALL   022
0967:  BSF    0A.3
0968:  GOTO   15D
.................... 
....................     }
.................... }
0969:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
